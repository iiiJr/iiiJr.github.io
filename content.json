{"meta":{"title":"小胖","subtitle":"写点什么","description":null,"author":"Jr'Blog","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-10-12T00:47:01.000Z","updated":"2019-10-12T15:45:53.060Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"孩儿立志出乡关，学不成名誓不还。"},{"title":"categories","date":"2019-10-11T15:14:13.000Z","updated":"2019-10-12T15:45:44.462Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-11T15:17:40.000Z","updated":"2019-10-12T15:45:48.986Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"trainingDiary_8","slug":"trainingDiary-8","date":"2019-12-21T16:38:16.000Z","updated":"2019-12-21T16:47:41.319Z","comments":false,"path":"2019/12/22/trainingDiary-8/","link":"","permalink":"http://yoursite.com/2019/12/22/trainingDiary-8/","excerpt":"","text":"2019-12-22 Chaincode helloworld第一个链码 helloWorld建 helloworld 文件夹，并在文件夹下新建 helloworld.go 和 helloworld_test.go编写链上代码 helloworld.go 导入关键依赖包 123456import ( \"fmt\" /*导入 chaincode shim 包和 peer protobuf 包*/ \"github.com/hyperledger/fabric/core/chaincode/shim\" \"github.com/hyperledger/fabric/protos/peer\"&#125; 实现了 Chaincode 接口 Init 方法和 Invoke 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// helloworld 结构体type HelloWorld struct &#123; &#125;//结构体中的初始化方法func (s *HelloWorld) Init(stub shim.ChaincodeStubInterface) peer.Response &#123; //接受 string 数组 args:= stub.GetStringArgs() if len(args) != 2 &#123; return shim.Error(\"要输入键和值\") &#125; //转为 k-v 写入区块链 err := stub.PutState(args[0],[]byte(args[1])) if err != nil &#123; shim.Error(err.Error()) &#125; return shim.Success(nil)&#125; //调用Chaincodefunc (s *HelloWorld) Invoke(stub shim.ChaincodeStubInterface) peer.Response&#123; //获取要调用的方法名和方法参数 fn, args := stub.GetFunctionAndParameters() //根据方法名调用方法（set，get） if fn ==\"set\" &#123; return s.set(stub, args) &#125;else if fn == \"get\"&#123; return s.get(stub, args) &#125; return shim.Error(\"方法不存在\")&#125;``` set 和 get 业务方法实现``` gofunc (s *HelloWorld) set(stub shim.ChaincodeStubInterface , args []string) peer.Response&#123; if len(args) != 2 &#123; return shim.Error(\"要输入键和值\") &#125; //写入 err := stub.PutState(args[0],[]byte(args[1])) if err != nil &#123; return shim.Error(err.Error()) &#125; return shim.Success(nil)&#125; func (s *HelloWorld) get(stub shim.ChaincodeStubInterface, args []string) peer.Response&#123; if len(args) != 1 &#123; return shim.Error(\"要输入一个键\") &#125; //读出 value, err := stub.GetState(args[0]) if err != nil &#123; return shim.Error(err.Error()) &#125; return shim.Success(value)&#125; 最后 main 方法，启动实例 func main(){ if err := shim.Start(new(HelloWorld)); err != nil { fmt.Println(\"HelloWorld start error\") } } 编写链上代码测试用例 helloworld_test.go利用 chaincode shim包 MockStub 的 MockInit 方法和 MockInvoke 方法 进行模拟测试 import ( \"fmt\" \"testing\" \"github.com/hyperledger/fabric/core/chaincode/shim\" ) var stub *shim.MockStub //测试 Init 方法 func testInit(t *testing.T, args [][]byte) { res := stub.MockInit(\"1\", args) if res.Status != shim.OK { fmt.Println(\"Init failed : \", string(res.Message)) t.FailNow() } } //测试 set 方法 func testSet(t *testing.T, key string, value string) { res := stub.MockInvoke(\"1\", [][]byte{[]byte(\"set\"), []byte(key),[]byte(value)}) if res.Status != shim.OK { fmt.Println(\"set\", key, \" failed : \", string(res.Message)) t.FailNow() } } //测试 get 方法 func testGet(t *testing.T, key string) { res := stub.MockInvoke(\"1\", [][]byte{[]byte(\"get\"), []byte(key)}) if res.Status != shim.OK { fmt.Println(\"get\", key, \"failed\", string(res.Message)) t.FailNow() } if res.Payload == nil { fmt.Println(\"get\", key, \"failed to get value\") t.FailNow() } fmt.Println(\"get value\", key, \" : \", string(res.Payload)) } //测试 func TestHelloWorld(t *testing.T) { //模拟实例 stub = shim.NewMockStub(\"helloworld\", new(HelloWorld)) testInit(t, [][]byte{[]byte(\"hi\"), []byte(\"jonluo\")}) testGet(t, \"hi\") testSet(t, \"say\",\"helloworld\") testGet(t,\"say\") } 在helloworld文件夹下执行 : go test -v helloworld_test.go helloworld.go 结果： === RUN TestHelloWorld get value hi : jonluo get value say : helloworld — PASS: TestHelloWorld (0.00s) PASS ok command-line-arguments 0.021s 第一个案例就算是成功了","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"trainingDiary_7","slug":"trainingDiary-7","date":"2019-12-20T14:57:17.000Z","updated":"2019-12-20T15:16:05.658Z","comments":false,"path":"2019/12/20/trainingDiary-7/","link":"","permalink":"http://yoursite.com/2019/12/20/trainingDiary-7/","excerpt":"","text":"2019-12-20-链码的概念与原理写在前面环境基本搭建完毕，但还是有一点小问题，但已经不影响开发了，所以可以开始学习fabric提供的接口编写代码了。 链码的概念：Chaincode：链上代码，简称链码，一般是指由开发人员使用Go语言（也支持Java等语言）编写的应用程序代码，提供分布式账本的状态处理逻辑。链码被部署在Fabric的网络节点中，能够独立运行在具有安全特性的受保护的 Docker 容器中，以 gRPC 协议与相应的 peer 节点进行通信，以操作（初始化或管理）分布式账本中的数据。可以根据不同的需求开发出不同的复杂的应用。 链码分类在 Hyperledger Fabric 中，链码一般分为： 系统链码用户链码 负责 Fabric 节点自身的处理逻辑, 包括系统配置、背书、校验等工作 系统链码仅支持 Go 语言, 在 Peer 节点启动时会自动完成注册和部署 系统链码共有五种类型：配置系统链码(CSCC) CSCC：Configuration System Chaincode，负责处理 Peer 端的 Channel 配置。 生命周期系统链码(LSCC) LSCC：Lifecycle System Chaincode，负责对用户链码的生命周期进行管理。 查询系统链码(QSCC) QSCC：Query System Chaincode，提供账本查询 API。如获取区块和交易等信息。 背书管理系统链码(ESCC) ESCC：Endorsement System Chaincode，负责背书(签名)过程, 并可以支持对背书策略进行管理（对提交的交易提案的模拟运行结果进行签名,，之后创建响应消息返回给客户端） 验证系统链码(VSCC) VSCC：Validation System Chaincode，处理交易的验证，包括检查背书策略以及多版本并发控制 用户链码由应用程序开发人员根据不同场景需求及成员制定的相关规则，使用 Golang（或Java等）语言编写的基于操作区块链分布式账本的状态的业务处理逻辑代码，运行在链码容器中，通过 Fabric 提供的接口与账本状态进行交互。 用户链码在整个应用程序中处于重要地位。因为它下可对账本数据进行操作，上可以给企业级应用程序提供调用接口。所以一个没有链码的企业级应用程序，不能称之为是基于区块链的企业级应用程序。 链码的生命周期管理链码开发编写完成后，并不能立刻使用，而是必须经过一系列的操作之后才能应用在 Hyperledger Fabric 网络中进而处理客户端提交的交易。这一系列的操作是由链码的生命周期来负责管理。 管理 Chaincode 的生命周期共有五个命令： install：将已编写完成的链码安装在网络节点中。 instantiate：对已安装的链码进行实例化。 upgrade：对已有链码进行升级。链代码可以在安装后根据具体需求的变化进行升级。 package：对指定的链码进行打包的操作。 singnpackage：签名。 状态其实指的就是账本中的数据。一个链码对应一个账本，所以一般情况下链码是不可以访问其它账本中的数据的。 链码接口链码启动必须通过调用 shim 包中的 Start 函数，而 Start 函数被调用时需要传递一个类型为 Chaincode 的参数，这个参数 Chaincode 是一个接口类型，该接口中有两个重要的函数 Init 与 Invoke 。chaincode接口的定义： 1234type Chaincode interface&#123; Init(stub ChaincodeStubInterface) peer.Response Invoke(stub ChaincodeStubInterface) peer.Response&#125; Init 与 Invoke 方法 编写链码，关键是实现 Init 与 Invoke 两个方法，必须由所有链码实现。Fabric 通过调用指定的函数来运行事务。 Init：在链码实例化或升级时被调用, 完成初始化数据的工作。invoke：更新或查询提案事务中的分类帐本数据状态时，Invoke 方法被调用， 因此响应调用或查询的业务实现逻辑都需要在此方法中编写实现。 必要结构依赖包shim 包为链码提供了 API 用来访问/操作数据状态、事务上下文和调用其他链代码；peer 包提供了链码执行后的响应信息。所以开发链码需要引入如下依赖包： 12345\"github.com/hyperledger/fabric/core/chaincode/shim\"shim 包提供了链码与账本交互的中间层。链码通过 shim.ChaincodeStub 提供的方法来读取和修改账本的状态。\"github.com/hyperledger/fabric/protos/peer\"peer.Response：封装的响应信息 也就是说一个开发的链码源文件的必要结构要像这样： 12345678910111213141516171819202122232425262728293031323334package main// 引入必要的包import( \"fmt\" \"github.com/hyperledger/fabric/core/chaincode/shim\" \"github.com/hyperledger/fabric/protos/peer\")// 声明一个结构体type SimpleChaincode struct &#123; &#125;// 为结构体添加Init方法func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) peer.Response&#123; // 在该方法中实现链码初始化或升级时的处理逻辑 // 编写时可灵活使用stub中的API&#125;// 为结构体添加Invoke方法func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response&#123; // 在该方法中实现链码运行中被调用或查询时的处理逻辑 // 编写时可灵活使用stub中的API&#125;// 主函数，需要调用shim.Start（ ）方法func main() &#123; err := shim.Start(new(SimpleChaincode)) if err != nil &#123; fmt.Printf(\"Error starting Simple chaincode: %s\", err) &#125;&#125;","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"trainingDiary_6","slug":"trainingDiary-6","date":"2019-12-19T13:57:19.000Z","updated":"2019-12-19T14:50:43.628Z","comments":false,"path":"2019/12/19/trainingDiary-6/","link":"","permalink":"http://yoursite.com/2019/12/19/trainingDiary-6/","excerpt":"","text":"2019-12-19-go web随笔go web 接收请求这个其实我昨天已经看过了一点，但昨天看的很杂，今天把它全部重新整理了一遍，内容如下： http.ListenAndServe（）的接收请求，输出响应的流程如下：首先调用Http.HandleFunc 按顺序做了几件事： 1 调用了DefaultServeMux的HandleFunc 2 调用了DefaultServeMux的Handle 3 往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则 其次调用http.ListenAndServe(“:9090”, nil) 按顺序做了几件事情： 1 实例化Server 2 调用Server的ListenAndServe() 3 调用net.Listen(“tcp”, addr)监听端口 4 启动一个for循环，在循环体中Accept请求 5 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve() 6 读取每个请求的内容w, err := c.readRequest() 7 判断handler是否为空，如果没有设置handler（这个例子就没有设置handler），handler就设置为DefaultServeMux 8 调用handler的ServeHttp 9 在这个例子中，下面就进入到DefaultServeMux.ServeHttp 10 根据request选择handler，并且进入到这个handler的ServeHTTPmux.handler(r).ServeHTTP(w, r) 11 选择handler： A 判断是否有路由能满足这个request（循环遍历ServerMux的muxEntry） B 如果有路由满足，调用这个路由handler的ServeHttp C 如果没有路由满足，调用NotFoundHandler的ServeHttp 流程图如下： go web处理请求数据在Go语言中，使用http.Request结构来处理http请求的数据，在我们定义处理请求的方法，会传入http.Request的实例，如下代码中request就是代表一个请求的实例。 123http.HandleFunc(\"/hello\", func(writer http.ResponseWriter, request *http.Request) &#123; //使用request可以获取http请求的数据&#125;) request公开可访问字段1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192type Request struct &#123; Method string //方法:POST,GET... URL *url.URL //URL结构体 Proto string // 协议：\"HTTP/1.0\" ProtoMajor int // 1 ProtoMinor int // 0 Header Header //头部信息 Body io.ReadCloser //请求实体 GetBody func() (io.ReadCloser, error) // Go 1.8 ContentLength int64 //首部：Content-Length TransferEncoding []string Close bool //是否已关闭 Host string //首部Host Form url.Values //参数查询的数据 PostForm url.Values // application/x-www-form-urlencoded类型的body解码后的数据 MultipartForm *multipart.Form //文件上传时的数据 Trailer Header RemoteAddr string //请求地址 RequestURI string //请求的url地址 TLS *tls.ConnectionState Cancel &lt;-chan struct&#123;&#125; // Response *Response // 响应数据&#125;``` ### 获得请求头(Header)``` gohttp.HandleFunc(\"/hello\", func(writer http.ResponseWriter, request *http.Request) &#123; request.RemoteAddr request.RequestURI request.ContentLength request.Proto request.Method request.Referer() request.UserAgent()&#125;)``` ### 获取查询参数(Query)``` go获取查询参数(url中?后面使用&amp;分隔的部分),用request.FormValue(key)方法获取查询参数，其中key为参数的名称，代码如下：package mainimport ( \"fmt\" \"net/http\")func main() &#123; http.HandleFunc(\"/hello\", func(writer http.ResponseWriter, request *http.Request) &#123; username := request.FormValue(\"username\") gender := request.FormValue(\"gender\") fmt.Fprintln(writer,fmt.Sprintf(\"用户名：%s,性别:%s\",username,gender)) &#125;) fmt.Println(http.ListenAndServe(\":8080\",nil))&#125;``` ### 获取表单信息(Form)我们说获取表单信息，一般是指获取Content-Type是application/x-www-form-urlencoded或multipart/form-data时，请求实体中的数据，如果你有做传统网页中的表单提交数据的经历，相信对这两种提交数据的方式应该是熟悉的，而multipart/form-data一般是用来上传文件的。application/x-www-form-urlencoded获取Content-Type为application/x-www-form-urlencoded时提交上来的数据，可以使用request.PostForm字段request.Form和request.PostFormValue(key)方法获取，但必须先调用request.ParseForm()将数据写入request.PostForm字段中。使用request.ParseForm()函数解析body参数，这时会将参数写入Form字段和PostForm字段当中。使用request.Form、request.PostForm或request.PostFormValue(key)都可以获取request.Form和request.PostForm的类型url.Values，结构定义如下``` gotype Values map[string][]string``` ``` go package mainimport ( \"fmt\" \"net/http\")func main()&#123; http.HandleFunc(\"/hello\", func(writer http.ResponseWriter, request *http.Request) &#123; err := request.ParseForm() if err != nil&#123; fmt.Fprintln(writer,\"解析错误\") &#125; username1 := request.PostForm[\"username\"][0] username2 := request.PostFormValue(\"username\") username3 := request.Form[\"username\"][0] fmt.Fprintln(writer,fmt.Sprintf(\"username1：%s,username2:%s,usernam3:%s\",username1,username2,username3)) &#125;) fmt.Println(http.ListenAndServe(\":8080\",nil))&#125; multipart/form-data获取Content-Type为multipart/form-data时提交上来的数据使用request.ParseMultipartForm(maxMemory)，解析参数，将参数写入到MultipartForm字段当中，其中maxMemory为上传文件最大内存。使用request.FormFile(文件域)，可以获取上传的文件对象：multipart.File除了文件域，其中参数可以从request.PostForm字段获取，注意，此时不需要再调用request.ParseForm()了。 12345678910111213141516package mainimport ( \"fmt\" \"net/http\")func main() &#123; http.HandleFunc(\"/upload\", func(writer http.ResponseWriter, request *http.Request) &#123; err := request.ParseMultipartForm(32 &lt;&lt; 20) if err != nil &#123; fmt.Fprintln(writer,\"文件上传错误\") return &#125; fmt.Println(request.FormFile(\"file\")) &#125;) fmt.Println(http.ListenAndServe(\":8080\",nil))&#125; 上头介绍的都是表单提交方式，但在现在前后端分离开发趋势和APP开发中，Content-Type指application/json才是更常见的数据提交方式。","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"trainingDiary_5","slug":"trainingDiary-5","date":"2019-12-18T14:12:06.000Z","updated":"2019-12-18T14:54:30.507Z","comments":false,"path":"2019/12/18/trainingDiary-5/","link":"","permalink":"http://yoursite.com/2019/12/18/trainingDiary-5/","excerpt":"","text":"学习go web写在前面关于ubuntu fabric框架方面简单测试案例，交给了队友，所以我先来学go web先了。 go webhttp包建立Web服务器1234567891011121314151617181920212223242526272829package main import ( \"fmt\" \"net/http\" \"strings\" \"log\")func sayhelloName(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() //解析参数，默认是不会解析的 fmt.Println(r.Form) //这些信息是输出到服务器端的打印信息 fmt.Println(\"path\", r.URL.Path) fmt.Println(\"scheme\", r.URL.Scheme) fmt.Println(r.Form[\"url_long\"]) for k, v := range r.Form &#123; fmt.Println(\"key:\", k) fmt.Println(\"val:\", strings.Join(v, \"\")) &#125; fmt.Fprintf(w, \"Hello astaxie!\") //这个写入到w的是输出到客户端的&#125; func main() &#123; http.HandleFunc(\"/\", sayhelloName) //设置访问的路由 err := http.ListenAndServe(\":9090\", nil) //设置监听的端口 if err != nil &#123; log.Fatal(\"ListenAndServe: \", err) &#125;&#125; go web中要编写一个Web服务器很简单，只要调用http包的两个函数就可以了。 web工作方式概念以下均是服务器端的几个概念 Request：用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息Response：服务器需要反馈给客户端的信息Conn：用户的每次请求链接Handler：处理请求和生成返回信息的处理逻辑 http包执行流程http包执行流程： 创建Listen Socket, 监听指定的端口, 等待客户端请求到来。 Listen Socket接受客户端的请求, 得到Client Socket, 接下来通过Client Socket与客户端通信。 处理客户端的请求, 首先从Client Socket读取HTTP请求的协议头, 如果是POST方法, 还可能要读取客户端提交的数据, 然后交给相应的handler处理请求, handler处理完毕准备好客户端需要的数据, 通过Client Socket写给客户端。 处理器和处理函数处理器一个处理器就是一个拥有ServeHTTPf方法的接口 1ServeHTTP(http.ResponseWriter, *http.Request) http.Handle可以将处理器绑定至DefaultServeMux 处理器函数处理器函数是一个具有特定签名的函数，即HandlerFunc。特定签名如下： 1type HandlerFunc func(ResponseWriter, *Request) 处理器函数只不过是创建处理器的一种便利的方法而已。Go语言拥有一种HandlerFunc函数类型，它可以把一个带有正确签名的函数f（即一个handlerFunc）转换成一个带有f的Handler。http.HandleFunc的内部实现，就是调用HandlerFunc函数来实现的。http.HandleFunc实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123; DefaultServeMux.HandleFunc(pattern, handler)&#125;func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123; mux.Handle(pattern, HandlerFunc(handler))&#125;``` #### 多路复用处理函数这最后的运行结果就是当你输入h1的时候进入第一个，h2第二个，h3第三个``` gopackage mainimport ( \"fmt\" \"net/http\")// 设置多个处理器函数func handler1(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"1 欢迎访问 www.ydook.com !\")&#125;func handler2(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"2 欢迎访问 www.ydook.com !\")&#125;func handler3(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"3 欢迎访问 www.ydook.com !\")&#125;func main() &#123; // 设置多路复用处理函数 mux := http.NewServeMux() mux.HandleFunc(\"/h1\", handler1) mux.HandleFunc(\"/h2\", handler2) mux.HandleFunc(\"/h3\", handler3) // 设置服务器 server := &amp;http.Server&#123; Addr: \"127.0.0.1:8000\", Handler: mux, &#125; // 设置服务器监听请求端口 server.ListenAndServe()&#125;","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"LAMP","slug":"ubuntuPhpmyadmin","date":"2019-12-17T16:14:33.000Z","updated":"2019-12-17T16:30:00.419Z","comments":false,"path":"2019/12/18/ubuntuPhpmyadmin/","link":"","permalink":"http://yoursite.com/2019/12/18/ubuntuPhpmyadmin/","excerpt":"","text":"1.安装nginx服务器 使用官方PPA安装 Nginx 最新版本，使用以下命令： 12345678add-apt-repository ppa:nginx/stableapt-get updateapt-get install nginx Nginx相关控制命令： 启动 ： /etc/init.d/nginx start 关闭 ： /etc/init.d/nginx stop 重启 ： /etc/init.d/nginx restart 查看状态 ： /etc/init.d/nginx status 2.安装PHP 123sudo apt-get install php5-cli php5-cgi php5-fpm php5-mcrypt php5-mysql ※记得安装完之后，一定要重启fpm/etc/init.d/php5-fpm restart 3.配置nginx 123 在修改之前，将默认的配置文件备份cp -pf /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bakvim /etc/nginx/sites-available/default 修改 root 为 “root /var/www/nginx;” 修改 index 为 “index index.html index.htm index.php;” 找到以下内容，把对应的前面#注释去掉，如下： 12345678910111213# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \\.php$ &#123; fastcgi_split_path_info ^(.+\\.php)(/.+)$; # NOTE: You should have &quot;cgi.fix_pathinfo = 0;&quot; in php.ini # With php5-cgi alone: fastcgi_pass 127.0.0.1:9000; # With php5-fpm: fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; include fastcgi_params;&#125; 4.安装MySQL数据库 12apt-get install mysql-server ※安装过程中会提示输入数据库root账号的密码。 5.安装phpmyadmin 1234apt-get install phpmyadmin ※安装过程中会提示输入数据库管理员权限的密码，和phpmyadmin自身登录的密码。 建立连接：ln -s /usr/share/phpmyadmin /var/www/phpmyadmin 6.测试，在游览器中打开 http://127.0.0.1/phpmyadmin","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"trainingDiary_4","slug":"daily4","date":"2019-12-17T13:27:47.000Z","updated":"2019-12-18T14:12:35.817Z","comments":false,"path":"2019/12/17/daily4/","link":"","permalink":"http://yoursite.com/2019/12/17/daily4/","excerpt":"","text":"2019-12-17-按着书籍开始搭建框架。写在前面经历了各种失败，今天书籍终于到了，开始按着书籍来做网络demo了，继续开始做demo。 按着书籍搭建环境我又一次重新搭建环境，跟着书籍上的框架重新搭建，书籍中有个是脚本搭建，有个是手动实现，我先是用脚本搭建，我使用脚本后，它一直卡在了一拉镜像的步骤，所以就放在那让他继续拉了，我开了另一个窗口实现了手动实现，搭建成功了。然后我继续按着书籍中的案例，编译生成工具，fabric框架搭建网络环境时需要的辅助工具有三个，分别是configtxgen，cryptogen，configtxlator这三个工具书籍上写的是使用命令make xxxxxx（xxxx未三个工具名字） 12iiijr@iiijr-virtual-machine:~/hyfa$ make configtxgenmake: *** No rule to make target &apos;configtxgen&apos;。 停止。 出现了新的报错，我快哭了，——————————————————————————————————————————吃完饭回来，百度了很久，没百度出来，好想我遇到的错，都没百度出了过！！！！——————————————————————————————————————————然后是接着去上课，上完课吃完饭后就是去开会。 回来后把问题都问了队友，让队友去试试搭建的成功吗。至于我，只能先去看下做好的项目中的源代码了。。。。","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"trainingDiary_3","slug":"daily3","date":"2019-12-16T15:33:17.000Z","updated":"2019-12-16T15:33:18.361Z","comments":false,"path":"2019/12/16/daily3/","link":"","permalink":"http://yoursite.com/2019/12/16/daily3/","excerpt":"","text":"2019-12-16-继续建立一个基于fabric网络的demo写在前面昨天晚上大概发现了自己没有上面东西所以创建不了新的网络demo，所以今天继续跟着问题寻找下去（漫无目的），今天继续试着搭建网络。 重新搭建环境今天一早醒来的第一件事就是给原来的环境拍了个快照，然后重新还原到初始快照，又搭建了一次整个fabric框架，搭建过程我就不复述了，网上很多教程，我是看着这个搭建的。 1https://www.jianshu.com/p/0ec409f77fb3 重新搭建环境又是一大堆乱七八糟的报错，东整整西搞搞，一早上就这样过去了，好在终于把初始环境搭建好了。 简单的事例在百度上找到了个fabric-samples的项目，是个测试项目，所以就跟着搭建了。博客地址在这。 1https://blog.csdn.net/qq_36956154/article/details/82317514 跟着它的搭建，我被卡在了这一步，也报了错，首先是调用一个cryptogen工具来生成各种网络实体加密材料。这里调用了跟他报了一样的错，然后他的下一步是在网上拉项目下来，我就在这里卡住了。 这是跟他一样情况的报错 123456[root@localhost first-network]# bash byfn.sh -m generateGenerating certs and genesis block for with channel &apos;mychannel&apos; and CLI timeout of &apos;10000&apos;Continue (y/n)? yproceeding ...which: no cryptogen in (/opt/gopath/src/github.com/hyperledger/fabric-samples/first-network/../bin:/opt/gopath/src/github.com/hyperledger/fabric-samples/first-network:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)cryptogen tool not found. exiting 然后是拉项目，在这里时，它拉不下来，一直报错。开始百度。 123456iiijr@iiijr-virtual-machine:~/go/src/github.com/hyperledger/fabric-samples/bin$ ./get-byfn.sh ===&gt; Downloading Build Your First Network sample application./get-byfn.sh: 行 13: VERSION: 未找到命令 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 995 0 995 0 0 333 0 --:--:-- 0:00:02 --:--:-- 333 我在查了各种资料，也翻了很多博客后，最后去这个地址看了下。我发现！！，根本没有这个文件，它换了地址！！！然后我跟着他换了地址。终于，它开始拉了！！然后我发现了新的问题，它拉的，实在是太慢了，我不清楚是网络问题还是什么问题。 12345iiijr@iiijr-virtual-machine:~/go/src/github.com/hyperledger/fabric-samples/bin$ curl https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.0.0/hyperledger-fabric-linux-amd64-1.0.0.tar.gz | tar xz % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 1 22.5M 1 387k 0 0 3017 0 2:10:45 0:02:11 2:08:34 0curl: (56) GnuTLS recv error (-54): Error in the pull function. 它拉了整整两个钟！！！这期间我一直在找别的源文件或者其他人已经下载过的文件，发现都没什么用，最后耐心等待。 终于它拉完了。我在我的ubuntu下文件目录下看到了bin，太激动了。马上开始下一步，执行脚本。新的开始，新的报错 1234567891011121314151617181920212223242526272829303132333435363738394041iiijr@iiijr-virtual-machine:~/go/src/github.com/hyperledger/fabric-samples/first-network$ bash byfn.sh -m generate Generating certs and genesis block for channel &apos;mychannel&apos; with CLI timeout of &apos;10&apos; seconds and CLI delay of &apos;3&apos; secondsContinue? [Y/n] yproceeding .../home/iiijr/go/src/github.com/hyperledger/fabric-samples/first-network/../bin/cryptogen############################################################### Generate certificates using cryptogen tool ###################################################################+ cryptogen generate --config=./crypto-config.yamlorg1.example.comorg2.example.com+ res=0+ set +xGenerate CCP files for Org1 and Org2/home/iiijr/go/src/github.com/hyperledger/fabric-samples/first-network/../bin/configtxgen################################################################### Generating Orderer Genesis block ########################################################################2019-12-16 18:46:22.296 CST [common/configtx/tool] main -&gt; INFO 001 Loading configuration2019-12-16 18:46:22.315 CST [common/configtx/tool/localconfig] Load -&gt; CRIT 002 Error unmarshaling config into struct: 17 error(s) decoding:* &apos;&apos; has invalid keys: capabilities, channel* &apos;Application&apos; has invalid keys: Capabilities, Policies* &apos;Orderer&apos; has invalid keys: Policies* &apos;Organizations[0]&apos; has invalid keys: Policies* &apos;Organizations[1]&apos; has invalid keys: Policies* &apos;Organizations[2]&apos; has invalid keys: Policies* &apos;Profiles[SampleMultiNodeEtcdRaft]&apos; has invalid keys: Capabilities, Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Application&apos; has invalid keys: Capabilities, Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Application.Organizations[0]&apos; has invalid keys: Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Consortiums[SampleConsortium].Organizations[0]&apos; has invalid keys: Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Consortiums[SampleConsortium].Organizations[1]&apos; has invalid keys: Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Orderer&apos; has invalid keys: Capabilities, EtcdRaft, Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Orderer.Organizations[0]&apos; has invalid keys: Policies* &apos;Profiles[TwoOrgsChannel]&apos; has invalid keys: Capabilities, Policies* &apos;Profiles[TwoOrgsChannel].Application&apos; has invalid keys: Capabilities, Policies* &apos;Profiles[TwoOrgsChannel].Application.Organizations[0]&apos; has invalid keys: Policies* &apos;Profiles[TwoOrgsChannel].Application.Organizations[1]&apos; has invalid keys: PoliciesFailed to generate orderer genesis block... 执行了脚本后，它报了这些错。我去百度了下，他们说的意思大概是说，我刚刚拉了两个小时拉下来的文件版本和这个fabric框架环境不符，已经崩溃。 开心找对应版本，是的，我又找到了对应版本，决定重拉一次，又等了无数时间，然后又执行了一次，然后还是同样的错误。然后我就一直卡在这一步，查找了各种资料，换了无数版本，重新搭建了无数次环境，可它还是不行。泪奔。。。还是要跟着书记来系统学比较现实，书籍到了，刚刚翻了几页，看了一下搭建环境啥的，没发现有什么大问题，决定明天好好跟着书籍来一遍，今天已经崩溃，洗个澡先，开溜。","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"trainingDiary_2","slug":"daily2","date":"2019-12-15T12:26:17.000Z","updated":"2019-12-17T13:34:00.470Z","comments":false,"path":"2019/12/15/daily2/","link":"","permalink":"http://yoursite.com/2019/12/15/daily2/","excerpt":"","text":"2019-12-15-建立一个基于fabric网络的demo（然而并没有成功）写在前面昨天看了sdk的基本包应用和了解了fabirc框架的一些部分节点组织通道之类的作用，但是也还没继续深入（这个先交给我的好队友吧），今天想先试着搭建一个新的网络demo并写一下基本的账户管理，可是我发现我并没搭出来。 问题：1:今天去网上可以说是搜了一整天的资料，太零零碎碎了，说的也不大仔细（可能是我太菜了），他们的做法都是先独立创建一个目录文件，我也跟着它创建了： 12mkdir -p $GOPATH/src/github.com/hyperledger/fabric-democd $GOPATH/src/github.com/hyperledger/fabric-demo 可是，创建完后，我就傻了，据博客所说，它上面有配置文件，它说先初始化容器，我初始化了，然后！然后生产节点PKI文件和创世块等基础配置，它是直接打了这两个命令！课我没有这个generate.sh啊！！！ 12cd basic-network/./generate.sh 好的，开始研究，它是哪来的，它说了一段话，说这是它写好的配置文件，可它没说写哪，我就自己找了下，发现它博客下面有github项目地址，配置文件是在那里，我就把它给考进了我的ubuntu中 1git clone https://github.com/wesker8088/fabric-account.git clone下来后，我将它放进我的文件夹中，然后运行它，它就报错了， 1./generate.sh: 16: ./generate.sh: cryptogen: not found Failed to generate crypto material... 翻译是未生成加密材料这个我也不知道是什么错，然后又开始找错误。网上找到的问题解答，各种各样，我也试了很多种，没有一种是可以的。也觉得很奇怪，不明白为什么，我就去看了fabric的中文文档，看看可不可以看出什么来。然后我就发现了，文档的环境搭建,因为我是搭建完成了环境的，我就接着他搭建完环境的步骤继续走下去，它上面写了个工具，叫configtxgen，它的作用是生成两个内容： Orderer的bootstrap block和Fabric的channel configuration transaction。然后我就在我搭建好的环境里，找这个工具，然而并没有找到。没有找到我也就先跳过了，在后面继续看别的，文档说它为了给我们方便使用，给了我们一个脚本，这脚本叫generateCfgTrx.sh，意思就是整合了上面的工具，帮我门生成那两个内容，然而我也没有这个脚本，至于为什么这些脚本为什么都没有，我也不是很清楚，可能是因为fabric版本不一样，也可能是安装环境是出现了我不知道的错误，所以我就继续往后看。文档中有一段，教我们怎么搭建第一个网络，我点进去看了，它说在例子中有一个脚本，可以帮助你快速搭建一个网络，然后，我这个脚本也没用，它叫byfn.sh。又开始了百度之旅，我搜的是fabric文件例子中为什么没有byfn.sh这个脚本，结果出来的百度，只有运行它之后为什么报错，好像没有人没遇到我这个情况，在加上百度资料也少，（人也快傻了）害！！！","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"trainingDiary_1","slug":"日记","date":"2019-12-14T06:38:13.000Z","updated":"2019-12-15T13:19:53.517Z","comments":false,"path":"2019/12/14/日记/","link":"","permalink":"http://yoursite.com/2019/12/14/日记/","excerpt":"","text":"2019-12-14-Fabric SDK写在前面关于框架的环境搭建已经完成，但是对整个框架的操作原理自己还是没摸清楚，在加上go语言也只是刚刚接触，还不是很能熟它的各种代码，因为队友是弄系统的，所以我不打算先深入到摸透整个框架，和队友分工，我先学开发那一块，他先深入，我们在一起互相学习，想了很多方案，不知道该从哪里入手好，因为对于整个框架还不是很熟悉，所以没急着先去弄智能合约什么的就先从框架开放的sdk入手了，sdk是一定要熟练的，如果对它都不熟悉，开始写代码可能报个错都要查半天，所以就从sdk先入手了。至于启动整个生鲜的项目的话还不怎么着急。先把go和sdk玩熟了后在开始去启动项目，看源码，学习一整个框架，必须先把基础打好，才能开始写代码。 Fabric SDK简介今天由于早上和下午都教学楼都是考试也进不去，只能在宿舍用手机看下部分sdk简介，晚上才过来开始查看整个sdk文档。简介大概说的就是：Farbric的Peer节点和Orderer节点都提供了基于gRPC协议的接口，用于和Peer节点与Orderer节点进行命令/数据交互。为了简化开发，为开发人员开发应用程序提供操作Fabric区块链网络的API，Fabric官方提供了多种语言版本的SDK。其中就有go的sdk（这里原本不知道gRPC是什么意思，查了后发现gRPC是用来指定一个可以远程调用的带有参数和返回类型的的方法。在服务端，服务实现这个接口并且运行gRPC服务处理客户端调用。在客户端，有一个stub提供和服务端相同的方法。）其实简单来说就是一个拿来服务端和客户端通信和简化通信系统的构建的，但记住它支持多种语言，基于http/2标准设计。 回到正题，fabric中可以通过SDK访问Fabric网络中的多种资源，包括账本、交易、链码、事件、权限管理等，应用程序代表用户与Fabric网络进行交互，Fabric SDK API提供了如下功能：A、创建通道B、将peer节点加入通道C、在peer节点安装链码D、在通道实例化链码E、通过链码调用交易F、查询交易或区块的账本 安装的话他是给出了fabric sdk 就在github上： 1go get -u github.com/hyperledger/fabric-sdk-go关于sdk的源码结构，其实就是说说包中的功能 123456pkg/fabsdk: Fabric SDK的主要包，允许基于配置创建上下文。上下文由客户端软件包使用。pkg/client/channel: 提供通道交易相关功能pkg/client/event: 提供通道事件相关功能pkg/client/ledger: 启用对通道底层账本的查询相关功能pkg/client/resmgmt: 提供资源管理功能，例如安装链码pkg/client/msp: 启用身份管理相关功能Fabric SDK功能模块API：对于应用开发者来说，插件化的API可以支持SDK提供的关键接口的可选实现。对于每个接口，都有内置的默认实现，也可以灵活自定义。（意思就是说有内置的包，但是当然你也可以自己实现） Fabric-client:这个包的话提供的API是框架的网络核心组件，就是对peer，order这些节点的进行交互。功能的话包括（创建channel，请求peer节点加入channel，在peer安装chaincode，在channel中实例化chaincode，调用chaincode来调用食物，查询分类账的事物或块等） 这里解释一下： peer：fabric网络中的节点，意思是一个运行这的docker容器，可以和网络中的其他peer进行通信，peer可以分为两种类型： endorsing peer/endorser：安装和执行chaincode等一系列操作都离不开peer，我们通常会说将chaincode安装在某个peer上。它既可以是模拟chaincode执行的endorser也可以是验证背书策略是否满足条件的 endorsing peer：安装和执行chaincode等一系列操作都离不开peer，我们通常会说将chaincode安装在某个peer上。它既可以是模拟chaincode执行的endorser也可以是验证背书策略是否满足条件的endorsing peer。 anchor peer被称为锚节点。作为一个channel或org的代表，从orderer获取信息，并且组内广播给其他peer。其他peer可以不直接跟orderer打交道。（它可能是个组长，老师给它通知他广播给别人，这样别人就不用单独去访问orderer了） Org一个或多个peer组成org。在文件crypto-config.yaml中可以设置如下block指定一个org中peer数量。（这个是组织org也本身就是组织的缩写，把节点们放在一起也就是组织了） Channelchannel指一个在两个或多个特定网络成员间的专门以机密交易为目的而建立的私有&quot;子网&quot;。（类似网络中的局域网吧，建立网络让成员在网络中交易，当然这比局域网要安全得多）刚刚开始不知道为什么要实例化所以去了解了下 在 Fabric 中，channel 代表了一个私有的广播通道，保证了消息的隔离性和私密性，它由 orderer 来管理。channel 中的成员共享该 channel 的账本，并且只有通过验证的用户才能在 channel 中进行交易，与一个 channel 相关的属性记录在该channel的初始区块中，可通过 reconfiguration 交易进行更改。channel的初始区块由 create channel 交易生成，peer 向 orderer 发送该交易时会带有的 config.tx 文件，该文件定义 channel 的属性。总的来说他们的关系就是下图： fabric-ca-clientfabric-ca-client模块提供与可选组件fabric-ca进行交互的API，fabric-ca提供成员管理服务。fabric-ca-client模块主要功能有（注册新用户，注册用户以获得由fabric CA签名的注册证书，通过注册ID撤销现有的用户或撤销特定证书，可定制持久化存储）（简单来说就是注册，删除用户用的） （整整花费了一个下午和晚上才找齐了关于框架的各种资料，在慢慢罗列，理解，在写出来，头大），总结了下今天也就是把整个sdk中的各种模块都理解一遍，再把重要的几个给罗列出来","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"记一次刷作业次数的脚本","slug":"记一次刷作业次数的脚本","date":"2019-10-15T09:44:51.000Z","updated":"2019-10-15T11:09:25.695Z","comments":false,"path":"2019/10/15/记一次刷作业次数的脚本/","link":"","permalink":"http://yoursite.com/2019/10/15/记一次刷作业次数的脚本/","excerpt":"","text":"教师次数刷新一个普通的登录界面 第一次输入账号密码后显示模拟发包应该发送的post地址，还有需要发送的数据包 百度后发现加密方式为base64，发包的时候需要加密一下，还有下载验证码图片到本地。然后登录后打开需要刷次数的url 重新发送这个包看看 发现它增加了，那只要发这个包就好了。 完成了一个，还有个学生页面的统计次数，这个页面我查看了好多次包也重新发送过试过很多次，发现都实现不了增加次数。 学生页面次数刷新但是手动刷新却可以，换个思路，决定在控制台打js代码了（哈哈哈哈哈） 次数增加了，搞定。 python贴部分代码，源码可去我的github中下载。源码：https://github.com/iiiJr/Homework下面贴一下js代码。 12345678910111213141516171819202122232425262728293031323334var timeout = prompt(\"设置刷新时间间隔[S]\"); // 获取当前的URL var current = location.href; if(timeout &gt; 0) &#123; // 时间间隔大于0，timeout秒之后执行reload函数 setTimeout('reload()', 1000 * timeout); &#125; else &#123; // 时间间隔不大于0，仅刷新一次 location.replace(current); &#125; function reload() &#123; // timeout秒后执行reload函数，实现无限循环刷新 setTimeout('reload()', 1000 * timeout); // 下面两行代码的格式化后的内容为： // &lt;frameset cols='*'&gt; // &lt;frame src='当前地址栏的URL' /&gt; // &lt;/frameset&gt; var fr4me = '&lt;frameset cols=\\'*\\'&gt;\\n&lt;frame src=\\'' + current + '\\' /&gt;'; fr4me += '&lt;/frameset&gt;'; with(document) &#123; // 引用document对象，调用write方法写入框架，打开新窗口 write(fr4me); // 关闭上面的窗口 void(close()); &#125;; &#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"队列","slug":"队列","date":"2019-10-12T10:38:54.000Z","updated":"2019-12-15T06:41:28.536Z","comments":false,"path":"2019/10/12/队列/","link":"","permalink":"http://yoursite.com/2019/10/12/队列/","excerpt":"","text":"ß 1.队列的概念只允许在一端插入数据操作，在另一端进行删除数据操作的特殊线性表；进行插入操作的一端称为队尾（入队列），进行删除操作的一端称为队头（出队列）；队列具有先进先出（FIFO）的特性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// main.cpp// Queue//// Created by ljr on 2019/10/12.// Copyright © 2019 ljr. All rights reserved.//#include &lt;iostream&gt;using namespace std;typedef struct QueueNode node;typedef struct QueueNode * link;struct QueueNode&#123; int data; struct QueueNode * next;&#125;;link front = NULL;link rear = NULL;void addQueue(int value)&#123; link newNode; newNode = (link)malloc(sizeof(node)); newNode -&gt; data = value; newNode -&gt; next = NULL; if (front == NULL) &#123; front = newNode; &#125;else&#123; rear -&gt; next = newNode; &#125; rear = newNode;&#125;int delQueue()&#123; link top; int temp; if (front != NULL) &#123; top = front; front = front -&gt; next; temp = top -&gt; data; free(top); return temp; &#125;else&#123; rear = NULL; return -1; &#125;&#125;void display()&#123; link point; point = front; while (point != NULL) &#123; cout &lt;&lt; point -&gt; data &lt;&lt; ' '; point = point -&gt; next; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int select; int temp = 0; while (1) &#123; cout &lt;&lt; \"1.input a data\\n\"; cout &lt;&lt; \"2.Output a data\\n\"; cout &lt;&lt; \"3.Exit\\n\"; cin &gt;&gt; select; switch (select) &#123; case 1: cout &lt;&lt; \"please input a value\\n\"; cin &gt;&gt; temp; addQueue(temp); break; case 2: if(delQueue() == -1) cout &lt;&lt; \"the queue is empty!\\n\"; else cout &lt;&lt; \"the out value is \" &lt;&lt; temp &lt;&lt; endl; break; case 3: return 0; &#125; system(\"clear\"); display(); &#125; return 0;&#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"栈","slug":"栈","date":"2019-10-11T09:49:43.000Z","updated":"2019-10-12T14:54:30.186Z","comments":false,"path":"2019/10/11/栈/","link":"","permalink":"http://yoursite.com/2019/10/11/栈/","excerpt":"","text":"用来自己学习用嘎 栈栈的主要特点就是先进后出；即后入的元素先出；可删除和增加元素操作的一端叫做栈顶；栈可以用指针来仿真也可以用数组来仿真；这里我用的是指针仿真栈；数组和指针仿真是不一样的，数组的话栈底一般为数组的第一个元素；而不是最后一个，因为在动态添加栈时如果栈顶是数组第一个元素的话就要使数组的每一个元素都移动一位；所以栈顶为数组最后一位数；指针的栈顶就是让原本的栈顶指向新插入的栈顶就可以了；栈底就是第一个插入的元素了；kk代码（函数中的代码都测试过，在主函数中调用既可）； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// main.cpp// stack//// Created by ljr on 2019/10/11.// Copyright © 2019 ljr. All rights reserved.//#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;typedef struct Stack * link;typedef struct Stack Snode;typedef int ElemType;//定义结构体struct Stack&#123; ElemType data; struct Stack * next;&#125;;//初始化栈link init()&#123; link p; p = NULL; return p;&#125;//入栈link push(link Head,ElemType x)&#123; link p; p = (link)malloc(sizeof(Snode)); if (p == NULL) &#123; cout &lt;&lt; \"\\nMemory Error\\n\"; &#125; p -&gt; data = x; p -&gt; next = Head; return p;&#125;//出栈link pop(link Head)&#123; link p; p = Head; if(p == NULL)&#123; cout &lt;&lt; \"\\nStack is Empty!\\n\"; &#125;else&#123; p = p -&gt; next; delete(Head); &#125; return p;&#125;//释放栈link setnull(link Head)&#123; link p; p = Head; while(p != NULL)&#123; p = p -&gt; next; delete Head; Head = p; &#125; return Head;&#125;//获取栈长度int lenth(link Head)&#123; int len = 0; link p; p = Head; while(p != NULL)&#123; len++; p = p -&gt; next; &#125; return len;&#125;//获取栈顶元素int gettop(link Head)&#123; if(Head == NULL)&#123; cout&lt;&lt;\"\\n Stack is empty\\n\"; return -1; &#125;else&#123; return Head -&gt; data; &#125;&#125;//显示栈void display(link Head)&#123; link p; p = Head; if (p == NULL) &#123; cout &lt;&lt; \"\\nStack is empty\\n\"; &#125;else&#123; do&#123; cout &lt;&lt; p -&gt; data &lt;&lt; \" \"; p = p -&gt; next; &#125;while(p != NULL); &#125;&#125;//主函数int main(void)&#123;// int i, x; link head1; head1 = init(); return 0;&#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"链表","slug":"链表","date":"2019-09-30T09:48:59.000Z","updated":"2019-10-12T14:54:26.819Z","comments":false,"path":"2019/09/30/链表/","link":"","permalink":"http://yoursite.com/2019/09/30/链表/","excerpt":"","text":"用来自己学习用嘎 头文件和结构1234567891011121314151617181920212223///// main.cpp// helloworld//// Created by ljr on 2019/9/29.// Copyright © 2019 ljr. All rights reserved.//#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct List * link; //代表链表指针typedef struct List Lnode; // 代表链表节点//结构struct List&#123; ElemType data; //创一个整型为例子8 struct List * next;&#125;; 创建链表函数123456789101112131415161718192021222324252627//创建链表link create(link Head)&#123; ElemType newData; link NewPoint; Head = (link)malloc(sizeof(Lnode)); printf(\"please input number: \\n\"); scanf(\"%d\",&amp;newData); Head -&gt; data = newData; Head -&gt; next = NULL; while(true)&#123; NewPoint = (link)malloc(sizeof(Lnode)); if(NewPoint == NULL) break; printf(\"please input number: input '-1' means exit\\n\"); scanf(\"%d\",&amp;newData); if (newData == -1) &#123; return Head; &#125; NewPoint -&gt; data = newData; NewPoint -&gt; next = Head; Head = NewPoint; &#125; return Head;&#125; 显示链表123456789101112//显示链表void display(link Head)&#123; link p; p = Head; if (p == NULL) &#123; printf(\"\\nList is empty\"); &#125;else&#123; do&#123; printf(\"%d\\n\", p -&gt; data); p = p -&gt; next; &#125;while(p != NULL); &#125;&#125; 插入节点、删除节点、获取节点、查找节点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//节点插入link insert(link Head,ElemType x,int i)&#123; link NewPoint,p = Head; int j = 1; NewPoint = (link)malloc(sizeof(Lnode)); NewPoint -&gt; data = x; if(i == 1)&#123; NewPoint -&gt; next = Head; Head = NewPoint; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125; &#125; if (j == i-1) &#123; NewPoint -&gt; next = p -&gt; next; p -&gt; next = NewPoint; &#125;else&#123; printf(\"insert is failure,i si not right\"); &#125; return Head;&#125;//删除节点link del(link Head,int i )&#123; int j=1; link p,t; p = Head; if(i == 1)&#123; p = p -&gt; next; free(Head); Head = p; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125;if(p -&gt; next != NULL &amp;&amp; j == i-1)&#123; t = p -&gt; next; p -&gt; next = t -&gt; next; &#125;if(t != NULL) free(t); &#125; return Head;&#125;//获取节点元素valueElemType get(link Head,int i)&#123; int j = 1; link p; p = Head; while (j &lt; i &amp;&amp; p != NULL ) &#123; p = p -&gt; next; j++; &#125; if (p != NULL) &#123; return (p -&gt; data); &#125;else&#123; printf(\"data is error!\"); return -1; &#125;&#125;//查找节点元素x的位置int locate(link Head, ElemType x)&#123; int n = 0; link p; p = Head; while (p != NULL &amp;&amp; p -&gt; data != x) &#123; p = p -&gt; next; n++; &#125; if(p == NULL)&#123; return -1; &#125;else&#123; return n+1; &#125;&#125; 链表逆置1234567891011121314151617//链表逆置link re(link Head)&#123; link p = Head; link n = NULL,temp; //n为保存的临时第一个链表节点，temp为第二个临时节点 if(p -&gt; next == NULL)&#123; return Head; &#125; while (p != NULL) &#123; temp = p; // 设置临时变量等于头节点 p = p -&gt; next; // 让p = p的下一个节点 temp -&gt; next = n; // 让p的下一个节点指向n n第一次是NULL 后面将会等于临时变量temp n = temp; // 让n = 要逆转的节点 &#125; return n;&#125; 其它功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546//返回链表的长度int lenth(link Head)&#123; int len = 0; link p; p = Head; while(p != NULL)&#123; len++; p = p -&gt; next; &#125; return len;&#125;//链接两个链表link connect(link Head1,link Head2)&#123; link p; p = Head1; while (p -&gt; next != NULL) &#123; p = p -&gt; next; &#125; p -&gt; next = Head2; return Head1;&#125;//比较两个链表int compare(link Head1,link Head2)&#123; link p1,p2; p1 = Head1; p2 = Head2; while (true) &#123; if((p1 -&gt; next == NULL)&amp;&amp;(p2 -&gt; next == NULL)) return 1; if (p1 -&gt; data != p2 -&gt; data) &#123; return 0; &#125;else&#123; p1 = p1 -&gt; next; p2 = p2 -&gt; next; &#125; &#125;&#125;//释放链表link setnull(link Head)&#123; link p; p = Head; while (p != NULL) &#123; p = p -&gt; next; free(Head); Head = p; &#125; return Head;&#125; main函数123456789101112131415161718192021222324252627282930313233343536373839404142434445int main()&#123; int l = 0; link head1 = NULL; link head2 = NULL; head1 = create(head1); printf(\"\\nHead1 is\\n\"); display(head1); head2 = create(head2); printf(\"\\nHead2 is\\n\"); display(head2); l = compare(head1, head2); printf(\"\\nl is %d\\n\",l); connect(head1, head2); printf(\"\\nHead1 + Head2 is\\n\"); display(head1); l = lenth(head1); printf(\"\\nlenth is %d\\n\",l); l = get(head1,3); printf(\"\\nget is %d\\n\",l); l = locate(head1, 12); printf(\"\\n locate 12 is %d\",l); head1 = insert(head1, 888, 5); display(head1); head1 = del(head1, 5); display(head1); printf(\"-------------逆置前kk---------------\\n\"); display(head1); printf(\"-------------逆置后kk---------------\\n\"); head1 = re(head1); display(head1); head1 = setnull(head1); display(head1);&#125; 完整代码可直接copy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249///// main.cpp// helloworld//// Created by ljr on 2019/9/29.// Copyright © 2019 ljr. All rights reserved.//#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct List * link; //代表链表指针typedef struct List Lnode; // 代表链表节点//结构struct List&#123; ElemType data; //创一个整型为例子8 struct List * next;&#125;;//创建链表link create(link Head)&#123; ElemType newData; link NewPoint; Head = (link)malloc(sizeof(Lnode)); printf(\"please input number: \\n\"); scanf(\"%d\",&amp;newData); Head -&gt; data = newData; Head -&gt; next = NULL; while(true)&#123; NewPoint = (link)malloc(sizeof(Lnode)); if(NewPoint == NULL) break; printf(\"please input number: input '-1' means exit\\n\"); scanf(\"%d\",&amp;newData); if (newData == -1) &#123; return Head; &#125; NewPoint -&gt; data = newData; NewPoint -&gt; next = Head; Head = NewPoint; &#125; return Head;&#125;//显示链表void display(link Head)&#123; link p; p = Head; if (p == NULL) &#123; printf(\"\\nList is empty\"); &#125;else&#123; do&#123; printf(\"%d\\n\", p -&gt; data); p = p -&gt; next; &#125;while(p != NULL); &#125;&#125;//节点插入link insert(link Head,ElemType x,int i)&#123; link NewPoint,p = Head; int j = 1; NewPoint = (link)malloc(sizeof(Lnode)); NewPoint -&gt; data = x; if(i == 1)&#123; NewPoint -&gt; next = Head; Head = NewPoint; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125; &#125; if (j == i-1) &#123; NewPoint -&gt; next = p -&gt; next; p -&gt; next = NewPoint; &#125;else&#123; printf(\"insert is failure,i si not right\"); &#125; return Head;&#125;//删除节点link del(link Head,int i )&#123; int j=1; link p,t; p = Head; if(i == 1)&#123; p = p -&gt; next; free(Head); Head = p; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125;if(p -&gt; next != NULL &amp;&amp; j == i-1)&#123; t = p -&gt; next; p -&gt; next = t -&gt; next; &#125;if(t != NULL) free(t); &#125; return Head;&#125;//获取节点元素valueElemType get(link Head,int i)&#123; int j = 1; link p; p = Head; while (j &lt; i &amp;&amp; p != NULL ) &#123; p = p -&gt; next; j++; &#125; if (p != NULL) &#123; return (p -&gt; data); &#125;else&#123; printf(\"data is error!\"); return -1; &#125;&#125;//查找节点元素x的位置int locate(link Head, ElemType x)&#123; int n = 0; link p; p = Head; while (p != NULL &amp;&amp; p -&gt; data != x) &#123; p = p -&gt; next; n++; &#125; if(p == NULL)&#123; return -1; &#125;else&#123; return n+1; &#125;&#125;//返回链表的长度int lenth(link Head)&#123; int len = 0; link p; p = Head; while(p != NULL)&#123; len++; p = p -&gt; next; &#125; return len;&#125;//链接两个链表link connect(link Head1,link Head2)&#123; link p; p = Head1; while (p -&gt; next != NULL) &#123; p = p -&gt; next; &#125; p -&gt; next = Head2; return Head1;&#125;//比较两个链表int compare(link Head1,link Head2)&#123; link p1,p2; p1 = Head1; p2 = Head2; while (true) &#123; if((p1 -&gt; next == NULL)&amp;&amp;(p2 -&gt; next == NULL)) return 1; if (p1 -&gt; data != p2 -&gt; data) &#123; return 0; &#125;else&#123; p1 = p1 -&gt; next; p2 = p2 -&gt; next; &#125; &#125;&#125;//释放链表link setnull(link Head)&#123; link p; p = Head; while (p != NULL) &#123; p = p -&gt; next; free(Head); Head = p; &#125; return Head;&#125;//链表逆置link re(link Head)&#123; link p = Head; link n = NULL,temp; //n为保存的临时第一个链表节点，temp为第二个临时节点 if(p -&gt; next == NULL)&#123; return Head; &#125; while (p != NULL) &#123; temp = p; // 设置临时变量等于头节点 p = p -&gt; next; // 让p = p的下一个节点 temp -&gt; next = n; // 让p的下一个节点指向n n第一次是NULL 后面将会等于临时变量temp n = temp; // 让n = 要逆转的节点 &#125; return n;&#125;int main()&#123; int l = 0; link head1 = NULL; link head2 = NULL; head1 = create(head1); printf(\"\\nHead1 is\\n\"); display(head1); head2 = create(head2); printf(\"\\nHead2 is\\n\"); display(head2); l = compare(head1, head2); printf(\"\\nl is %d\\n\",l); connect(head1, head2); printf(\"\\nHead1 + Head2 is\\n\"); display(head1); l = lenth(head1); printf(\"\\nlenth is %d\\n\",l); l = get(head1,3); printf(\"\\nget is %d\\n\",l); l = locate(head1, 12); printf(\"\\n locate 12 is %d\",l); head1 = insert(head1, 888, 5); display(head1); head1 = del(head1, 5); display(head1); printf(\"-------------逆置前kk---------------\\n\"); display(head1); printf(\"-------------逆置后kk---------------\\n\"); head1 = re(head1); display(head1); head1 = setnull(head1); display(head1);&#125; 2019.10.09 增加递归逆置链表；123456789101112131415161718192021222324252627282930313233343536373839404142//测试代码如下#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct List * link; //代表链表指针typedef struct List Lnode; // 代表链表节点//结构struct List&#123; ElemType data; //创一个整型为例子8 struct List * next;&#125;;List * reverseList(List * Head)&#123; //如果链表为空或者链表中只有一个元素 if (Head -&gt; next == NULL || Head == NULL) &#123; return Head; &#125;else&#123; List * newHead = reverseList(Head -&gt; next); //先反转后面的链表 Head -&gt; next -&gt; next = Head; //再将当前节点设置为其然来后面节点的后续节点 Head -&gt; next = NULL; return newHead; &#125;&#125;int main()&#123; link head1 = NULL; head1 = create(head1); printf(\"\\nHead1 is\\n\"); printf(\"-------------逆置前kk---------------\\n\"); display(head1); printf(\"-------------逆置后kk---------------\\n\"); head1 = reverseList(head1); display(head1);&#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"git","slug":"git","date":"2019-09-29T09:48:19.000Z","updated":"2019-10-12T15:30:53.488Z","comments":false,"path":"2019/09/29/git/","link":"","permalink":"http://yoursite.com/2019/09/29/git/","excerpt":"","text":"记一次小作业默认已经下载git第一步先生成ssh秘钥吧哈哈哈哈，具体创建方法看下面的网址8。 https://blog.csdn.net/lucky__yang/article/details/80148420 好了后就开始创建个仓库8.不会创建？那看这个，看到创建完仓库8. https://blog.csdn.net/qq_35869389/article/details/79472564 再在本地计算机中创建一个test文件夹 随便打点东西在cpp中 进入文件夹后再Git中输入init 再输入git status查看文件下都有什么文件 利用 git add main.cpp添加文件在打一次Git status就会有绿色的文件表示成功 最后成功","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"from表单提交检测","slug":"from表单提交检测","date":"2019-09-21T09:46:56.000Z","updated":"2019-10-12T14:54:40.883Z","comments":false,"path":"2019/09/21/from表单提交检测/","link":"","permalink":"http://yoursite.com/2019/09/21/from表单提交检测/","excerpt":"","text":"以前一直认为form是只能直接提交数据的，直到今天突然发现先看看一个简单的html代码：一个简单的提交没什么的 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"login.css\" type=\"text/css\"&gt; &lt;script type=\"text/javascript\" src=\"jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"login.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"loginBigArea\" &gt; &lt;div class=\"loginInsideArea\"&gt; &lt;form id=\"loginForm\" action=\"login\"&gt; &lt;div class=\"loginTitle\"&gt;登录&lt;/div&gt; &lt;input type=\"text\" placeholder=\"学号\" class=\"scanf\" id=\"stuNum\"&gt;&lt;br&gt; &lt;input type=\"password\" placeholder=\"密码\" class=\"scanf\" id=\"pwd\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"subBut\"&gt;&lt;br&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在来看看js中的代码 12345678910111213141516171819202122232425262728293031323334function checkStuNum() &#123; var num = $(\"#stuNum\").val(); var reg_num = /^\\w&#123;8&#125;$/; var flag = reg_num.test(num); if(flag)&#123; $(\"#stuNum\").css(\"border\",\"1px solid #5eb6de\"); &#125;else&#123; $(\"#stuNum\").css(\"border\",\"1px solid red\"); &#125; return flag; //这里返回的数据如果是false，那表单将不会提交&#125;function checkPwd() &#123; var pwd = $(\"#pwd\").val(); var reg_pwd = /^\\w&#123;6,20&#125;$/; var flag = reg_pwd.test(pwd); if(flag)&#123; $(\"#pwd\").css(\"border\",\"1px solid #5eb6de\"); &#125;else&#123; $(\"#pwd\").css(\"border\",\"1px solid red\"); &#125; return flag; //这里返回的数据如果是false，那表单将不会提交&#125;$(function () &#123; //当表单提交时调用所有校验方法 $(\"#loginForm\").submit(function () &#123; return checkStuNum() &amp;&amp; checkPwd(); &#125;); //当鼠标失去焦点，调用校验方法 $(\"#stuNum\").blur(checkStuNum); $(\"#pwd\").blur(checkPwd);&#125;) 是的，这样做之后，表单会在检测之后才提交！！！可能是我没好好学js的原因吧，才知道可以这样子。","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"ajax","slug":"ajax","date":"2019-09-21T09:45:52.000Z","updated":"2019-10-12T14:54:33.978Z","comments":false,"path":"2019/09/21/ajax/","link":"","permalink":"http://yoursite.com/2019/09/21/ajax/","excerpt":"","text":"自己遇到的小问题 ajax提交后获取不到数据#2019/05/26 123456&lt;form id=\"loginForm\" action=\"../checkLoginServlet\"&gt;&lt;div class=\"loginTitle\"&gt;登录&lt;/div&gt;&lt;input type=\"text\" placeholder=\"学号\" class=\"scanf\" id=\"stuNum\"&gt;&lt;br&gt;&lt;input type=\"password\" placeholder=\"密码\" class=\"scanf\" id=\"pwd\" &gt;&lt;br&gt;&lt;input type=\"submit\" class=\"subBut\"&gt;&lt;br&gt;&lt;/form&gt; 提交不到数据时我是这样写的 1234567//后来才知道，表单序列化 都是user=xxx&amp;xxx 这种格式，所以需要在&lt;input&gt;标签中添加一个name，才能序列号 &lt;form id=\"loginForm\" action=\"../checkLoginServlet\"&gt; &lt;div class=\"loginTitle\"&gt;登录&lt;/div&gt; &lt;input type=\"text\" placeholder=\"学号\" class=\"scanf\" id=\"stuNum\" name=\"stuNum\"&gt;&lt;br&gt; &lt;input type=\"password\" placeholder=\"密码\" class=\"scanf\" id=\"pwd\" name=\"pwd\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"subBut\"&gt;&lt;br&gt; &lt;/form&gt;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"js转jquery","slug":"js转jquery","date":"2019-09-21T09:44:23.000Z","updated":"2019-10-12T14:55:00.387Z","comments":false,"path":"2019/09/21/js转jquery/","link":"","permalink":"http://yoursite.com/2019/09/21/js转jquery/","excerpt":"","text":"js对象转换成jquery对象#2019/05/26 123456789//serialize() 方法通过序列化表单值，创建 URL 编码文本字符串。//你可以选择一个或多个表单元素（比如 input 及/或 文本框），或者 form 元素本身。//序列化的值可在生成 AJAX 请求时用于 URL 查询字符串中。$(\"form\").serialize()//输出后会变成a=1&amp;b=2&amp;c=3&amp;d=4&amp;e=5","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"docker","slug":"docker","date":"2019-09-19T09:42:48.000Z","updated":"2019-10-12T14:54:37.448Z","comments":false,"path":"2019/09/19/docker/","link":"","permalink":"http://yoursite.com/2019/09/19/docker/","excerpt":"","text":"docke的基本使用:容器的创建还有镜像的下载看网址就好：1https://www.runoob.com/docker/docker-install-tomcat.html 常用命令大全： 先了解下基础操作命令 镜像: 应用程序所依赖的操作环境和配置形成的模板，用面向对象的话来说简称类 容器: 通过镜像来运行容器，容器相当于类的实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576ip addr/ip link/ ifconfig：查看宿主机里ip地址（宿主机表示是虚拟机)systemctl start docker/service start docker：启动docker服务systemctl stop docker:关闭docker服务service iptables start:启动防火墙service iptables restart:重启防火墙service iptables stop:关闭防火墙docker run：启动containerdocker seach xxxx(镜像名称):检索镜像docker pull xxx(镜像名称）：拉取镜像docker images:列出镜像docker --version:查看docker的版本信息[root@localhost ~]:家目录[root@localhost /]:根目录docker exec Container Id:进入容器docker exec -it NAMES(自定义名称) /bin/bash:进入--name命名的容器docker exec NAMES(容器的自定义名称）-it bash:进入容器里进行操作docker attach Container Id:进入到容器的终端docker inspect IMAGE ID:显示容器或镜像的元数据[root@（container id）]：比如[root@24527d42d3eb]表示已进入docker里的一个CONTAINER ID的容器内部[root@24527d42d3eb]:exit(从容器里退出）。docker ps：查看docker里运行的容器（status为Up....表示运行中）docker ps -a:查看docker里已停止或正在运行的容器（status为Exit)docker start CONTAINER ID ：如果容器的状态为Exit,用它来启动容器docker stop CONTAINER ID :停止正在运行的容器，删除一个容器必须先要停止docker restart :当部署web项目的war文件，到tomcat里的webapps里面了，重启一下docker服务，就自动解压了war文件docker rm CONTAINER ID ：删除容器docker rm $(docker ps -a -q)：删除所有已停止的容器;docekr rmi IMAGE ID:删除镜像rm -rf xxxx：强制删除某个war.文件或目录、文件docker cp /xxx.war CONTAINER ID :/usr/local/tomcat/webapps：从/根目录复制一个打包后的Java web war文件 到tomcat容器里的webapps工作目录里docker exec CONTAINER ID ls /usr/local/tomcat:默认的 安装tomcat镜像的webapps目录docker run -name xxx -p (自定义端口号,用来访问的):(容器的端口号：比如tomcat的8080，mysql的3306） -d docker.io/tomcat(镜像名称)：表示在docker里运行一个tomcat容器,如果没有镜像，自动pull一个tomcat的镜像--name 为容器取一个名字-p 容器要映射的端口号-d:后台运行-t：进入终端-i：获得一个交互式的连接，通过获取container的输入/bin/bash：在container中启动一个bash shell 因为我只在docker中建立了tomcat的和mysql两个环境，所以这里就只讲讲tomcat和mysql的创建： 开始安装tomcat1234567891011输入这条命令docker run --name tomcat -p 8080:8080 -d tomcat在用docker ps查看的时候显示的是eee4f17b3f78 tomcat \"catalina.sh run\" 15 seconds ago Up 14 seconds 0.0.0.0:8080-&gt;8080/tcp tomcat默认是0.0.0.0:8080登录这个网址就会出现tomcat主页127.0.0.1:8080不行，就去百度了一下端口映射的问题然后发现在创建的时候用这条语句之后就可以访问了将本机的端口映射过去了，在本机浏览器中输入127.0.0.1:8080或localhost:8080既可docker run --name tomcat -p 127.0.0.1:8080:8080 -d tomcat mysql的话12345这条语句就搞定了 其中的东西自己配置docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7然后输入docker exec -it mysql /bin/bashmysql -uroot -p123456 测试成功；就Vans了","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"scrapy","slug":"scrapy","date":"2019-09-18T09:38:44.000Z","updated":"2019-10-12T14:55:04.208Z","comments":false,"path":"2019/09/18/scrapy/","link":"","permalink":"http://yoursite.com/2019/09/18/scrapy/","excerpt":"","text":"Scrapy框架的安装先pip install wheel,在去 1https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载 1lxml‑4.3.4‑cp36‑cp36m‑win_amd64.whll 注意根据型号什么的下载，然后再 1pip install 下载的文件地址 然后再去 1https://pypi.org/project/pyOpenSSL/#downloads 下载 1pyOpenSSL-19.0.0-py2.py3-none-any.whl 继续 1https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载 1twain‑1.0.4‑cp36‑cp36m‑win_amd64.whl 继续 1https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/ 下载 12pywin32-221.win-AMD64-py3.6.exe (这个我没找到最后用pip install pywin32成功安装的溜了溜了。) 遇到了各种问题，我累了，懒得一一列出来 scrapy调试工具命令行中输入 1scrapy shell http://lab.scrapyd.cn scrapy shell 固定格式，后面的话跟的是你要调试的页面，如果是百度就： 1scrapy shell (http://www.baidu.com)(URL可改变) 就这样一个格式，其实这段代码就是一个下载的过程，一执行这么一段代码scrapy就立马把我们相应链接的相应页面给拿到了，那接下来就可以任你处置了。 在要提前的调试界面In中输入 1response.css('title') 之类的语句就可以自动调试了 scrapy框架的基本使用在需要创建的目录下打开cmd 1然后输入 scrapy startproject /项目名称/. 在输入需要爬取的URL进入创建的目录下 1输入 scrapy genspider quotes /URL/. 这里也可以手动创建一个python文件，同理: 12345678910111213141516171819202122232425262728293031323334import scrapyclass mingyan(scrapy.Spider): #需要继承scrapy.Spider类 name = \"mingyan2\" # 定义蜘蛛名 def start_requests(self): # 由此方法通过下面链接爬取页面 # 定义爬取的链接 urls = [ 'http://lab.scrapyd.cn/page/1/', 'http://lab.scrapyd.cn/page/2/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) #爬取到的页面如何处理？提交给parse方法处理 def parse(self, response): ''' start_requests已经爬取到页面，那如何提取我们想要的内容呢？那就可以在这个方法里面定义。 这里的话，并木有定义，只是简单的把页面做了一个保存，并没有涉及提取我们想要的数据，后面会慢慢说到 也就是用xpath、正则、或是css进行相应提取，这个例子就是让你看看scrapy运行的流程： 1、定义链接； 2、通过链接爬取（下载）页面； 3、定义规则，然后提取数据； 就是这么个流程，4不4很简单呀？ ''' page = response.url.split(\"/\")[-2] #根据上面的链接提取分页,如：/page/1/，提取到的就是：1 filename = 'mingyan-%s.html' % page #拼接文件名，如果是第一页，最终文件名便是：mingyan-1.html with open(filename, 'wb') as f: #python文件操作，不多说了； f.write(response.body) #刚才下载的页面去哪里了？response.body就代表了刚才下载的页面！ self.log('保存文件: %s' % filename) # 打个日志 scrapy css选择器的使用12输入response.css('title')可以得到[&lt;Selector xpath='descendant-or-self::title' data='&lt;title&gt;xxxxxxxxxxxxxxxxx&lt;/title&gt;'&gt;]类似的东西 如果你加上 1234567891011response.css('title').extract()这个他就会变成['&lt;title&gt;xxxxxxxxxxx&lt;/title&gt;']列表的形式，如果不需要列表可以这样。response.css('title').extract_first()，那么爬下来的数据为这样 '&lt;title&gt;xxxxxxxxxxx&lt;/title&gt;' extract_first()就代表提取第一个元素（我想这个谁都看得出来） 当然如果你觉得怎么多了个title标签 那你可以这样： response.css('title::text').extract_first() 这样爬下来的数据就是xxxxxxxxxxx了 我们该如何提取URL呢？提取属性我们是用：“标签名::attr(属性名)”，比如我们要提取url表达式就是：a::attr(href)，要提取图片地址的表达式就是：img::attr(src)……以此类推：获取所有a标签下的所以href 1response.css(\"a::attr(href)\") 获取固定class样式下的标签 1response.css(\".page-navigator a::attr(href)\").extract() 如果是src那就要这样写 1response.css(\".xxxx img::attr(src)\").extract() 还有好多,自己发挥。 xpath提取数据123456nodename = 选取此节点的所有子节点。/ = 从根节点选取。// = 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。. = 选取当前节点。.. = 选取当前节点的父节点。@ = 选取属性。 response.xpath(“表达式”)，提取属性的话既然使用：@，那我们要提取href就是：@href 12In: response.xpath(\"@href\")out: [] 可以看到输出为0,因为我们木有限定从哪里提取,一般我们都需要加个：//，再来试试 1234567891011121314In: response.xpath(\"//@href\")out: [&lt;Selector xpath='//@href' data='//cdnjscn.b0.upaiyun.com/libs/normalize/'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/usr/themes/default'&gt;, …… &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E7%8E%8B%E5%B'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E6%99%BA%E6%8'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E6%B3%B0%E6%8'&gt;,…… &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E8%AF%8D/'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn'&gt;, &lt;Selector xpath='//@href' data='http://bbs.scrapyd.cn'&gt;, &lt;Selector xpath='//@href' data='http://www.scrapyd.cn'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/'&gt;] 已经提取到了，只是这是这个页面所有的href，并非是我们想要的，那和css选择一样我们需要加以限制.例如一个ol标签下 123456789In: response.xpath(\"//ol//@href\")Out:[&lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/1/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/2/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/3/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/4/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/6/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/2/'&gt;] “//ol//@href”，这个表达式表示：ol标签下所有的href属性值，可以看到我们这里限定了html的ol标签，这里的话页面只有一个ol，不会出错，如果页面中有多个ol，那就不一定能得到我们想要的结果,这里我们还能限定我们的属性，使用的是：标签[@属性名=’属性值’]； 例如： 123&lt;ol class=\"page-navigator\"&gt; ……&lt;/ol&gt; 里面有个：class=“page-navigator”，那我们就可以这样限制：//ol[@class=”page-navigator”]//@href 好了，这样的话就能让ol尽量缩小范围，我们再来试试这个代码效果： 1234567891011121314In : response.xpath(\"//ol[@class='page-navigator']//@href\")Out:[&lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/1/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/2/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/3/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/4/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/6/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/2/'&gt;] 可以看到也是同样得到想要的效果，以此类推，可以根据自己的情况来缩小范围如果这里的属性是id那就：ol[@id=’page-navigator’]和css选择器一样，xpath中也有extract（）、extract_first()这两个函数，加上就可以提取纯粹的href值了 ——————————–分割 接下来我们提取标签里面的内容，表达式： //text()，其实就是提取文本（不想说了，放个例子你们会懂得） 12In : response.xpath(\"//title//text()\").extract()Out: ['xxxxxxxxxxx'] 可以看到，表达式为：//title//text() ，就是用到了：//text() 这个表达式，前面的：//title是限定你要提取的范围，同理如果你要提取首页右侧的标签，如下： 12345678910111213141516171819&lt;ul class=\"tags-list\"&gt; &lt;li&gt;&lt;a style=\"color:rgb(101,86, 72)\" href=\"http://lab.scrapyd.cn/tag/%E4%BA%BA%E7%94%9F/\"&gt; 人生&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a style=\"color:rgb(214,236, 5)\" href=\"http://lab.scrapyd.cn/tag/%E5%8A%B1%E5%BF%97/\"&gt; 励志&lt;/a&gt;&lt;/li&gt; …… &lt;li&gt;&lt;a style=\"color:rgb(4,4, 41)\" href=\"http://lab.scrapyd.cn/tag/%E7%BB%9D%E4%B8%96%E5%A5%BD%E8%AF%8D/\"&gt; 绝世好词&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a style=\"color:rgb(204,12, 225)\" href=\"http://lab.scrapyd.cn/tag/%E6%9C%A8%E5%BF%83/\"&gt; 木心&lt;/a&gt;&lt;/li&gt; …… &lt;li&gt;&lt;a href=\"http://lab.scrapyd.cn\"&gt;返回首页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"http://bbs.scrapyd.cn\" target=\"_blank\"&gt;SCRAPY中文社区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.scrapyd.cn\" target=\"_blank\"&gt;SCRAPY中文网&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 可以看到标签文字是在 “class=tags-list” 的ul里面，那我们就可以这样写表达式：//ul[@class=’tags-list’]//a//text()，具体代码如下： 1234567891011121314151617In [5]: response.xpath(\"//ul[@class='tags-list']//a//text()\").extract()Out[5]:['\\r\\n 人生', '\\r\\n 励志', '\\r\\n 爱情', '\\r\\n 王尔德', '\\r\\n 智慧', '\\r\\n 泰戈尔', '\\r\\n 绝世好词', '\\r\\n 木心', '\\r\\n 艺术', '\\r\\n 名画', '\\r\\n 生活', '\\r\\n 词', '返回首页', 'SCRAPY中文社区', 'SCRAPY中文网'] 可以看到经过这样的限制，我们就定位到了； ——————–分割线 包含HTML标签的所有文字内容提取：string() 如果我们用表达式：//div[@class=’post-content’]//text()，你会发现虽然能提取但是一个列表，不是整段文字：那这里我们就用到一个xpath函数：string()，我们可以把表达式这样写：response.xpath(“string(//div[@class=’post-content’])”).extract()，可看到我们没有使用：text()，而是用：string(要提取内容的标签)，这样的话就能把数据都提取出来了，而且都合成为一条。","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-17T05:38:44.000Z","updated":"2019-10-12T14:54:54.856Z","comments":false,"path":"2019/09/17/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/17/hello-world/","excerpt":"","text":"note很久前就想自己搭个博客，当时想自己手写前端后端，终于在最后放弃了(Hexo真香)这里我就放平时自己做做的菜鸡笔记还有一些自己遇到的弱鸡问题好了 1$ My first note","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]}