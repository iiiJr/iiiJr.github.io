{"meta":{"title":"小胖","subtitle":"写点什么","description":null,"author":"Jr'Blog","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-10-12T00:47:01.000Z","updated":"2019-10-12T15:45:53.060Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"孩儿立志出乡关，学不成名誓不还。"},{"title":"categories","date":"2019-10-11T15:14:13.000Z","updated":"2019-10-12T15:45:44.462Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-11T15:17:40.000Z","updated":"2019-10-12T15:45:48.986Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"队列","slug":"队列","date":"2019-10-12T10:38:54.000Z","updated":"2019-10-12T14:52:42.234Z","comments":false,"path":"2019/10/12/队列/","link":"","permalink":"http://yoursite.com/2019/10/12/队列/","excerpt":"","text":"ß 1.队列的概念只允许在一端插入数据操作，在另一端进行删除数据操作的特殊线性表；进行插入操作的一端称为队尾（入队列），进行删除操作的一端称为队头（出队列）；队列具有先进先出（FIFO）的特性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// main.cpp// Queue//// Created by ljr on 2019/10/12.// Copyright © 2019 ljr. All rights reserved.//#include &lt;iostream&gt;using namespace std;typedef struct QueueNode node;typedef struct QueueNode * link;struct QueueNode&#123; int data; struct QueueNode * next;&#125;;link front = NULL;link rear = NULL;void addQueue(int value)&#123; link newNode; newNode = (link)malloc(sizeof(node)); newNode -&gt; data = value; newNode -&gt; next = NULL; if (front == NULL) &#123; front = newNode; &#125;else&#123; rear -&gt; next = newNode; &#125; rear = newNode;&#125;int delQueue()&#123; link top; int temp; if (front != NULL) &#123; top = front; front = front -&gt; next; temp = top -&gt; data; free(top); return temp; &#125;else&#123; rear = NULL; return -1; &#125;&#125;void display()&#123; link point; point = front; while (point != NULL) &#123; cout &lt;&lt; point -&gt; data &lt;&lt; ' '; point = point -&gt; next; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int select; int temp = 0; while (1) &#123; cout &lt;&lt; \"1.input a data\\n\"; cout &lt;&lt; \"2.Output a data\\n\"; cout &lt;&lt; \"3.Exit\\n\"; cin &gt;&gt; select; switch (select) &#123; case 1: cout &lt;&lt; \"please input a value\\n\"; cin &gt;&gt; temp; addQueue(temp); break; case 2: if(delQueue() == -1) cout &lt;&lt; \"the queue is empty!\\n\"; else cout &lt;&lt; \"the out value is \" &lt;&lt; temp &lt;&lt; endl; break; case 3: return 0; &#125; system(\"clear\"); display(); &#125; return 0;&#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"栈","slug":"栈","date":"2019-10-11T09:49:43.000Z","updated":"2019-10-12T14:54:30.186Z","comments":false,"path":"2019/10/11/栈/","link":"","permalink":"http://yoursite.com/2019/10/11/栈/","excerpt":"","text":"用来自己学习用嘎 栈栈的主要特点就是先进后出；即后入的元素先出；可删除和增加元素操作的一端叫做栈顶；栈可以用指针来仿真也可以用数组来仿真；这里我用的是指针仿真栈；数组和指针仿真是不一样的，数组的话栈底一般为数组的第一个元素；而不是最后一个，因为在动态添加栈时如果栈顶是数组第一个元素的话就要使数组的每一个元素都移动一位；所以栈顶为数组最后一位数；指针的栈顶就是让原本的栈顶指向新插入的栈顶就可以了；栈底就是第一个插入的元素了；kk代码（函数中的代码都测试过，在主函数中调用既可）； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// main.cpp// stack//// Created by ljr on 2019/10/11.// Copyright © 2019 ljr. All rights reserved.//#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;typedef struct Stack * link;typedef struct Stack Snode;typedef int ElemType;//定义结构体struct Stack&#123; ElemType data; struct Stack * next;&#125;;//初始化栈link init()&#123; link p; p = NULL; return p;&#125;//入栈link push(link Head,ElemType x)&#123; link p; p = (link)malloc(sizeof(Snode)); if (p == NULL) &#123; cout &lt;&lt; \"\\nMemory Error\\n\"; &#125; p -&gt; data = x; p -&gt; next = Head; return p;&#125;//出栈link pop(link Head)&#123; link p; p = Head; if(p == NULL)&#123; cout &lt;&lt; \"\\nStack is Empty!\\n\"; &#125;else&#123; p = p -&gt; next; delete(Head); &#125; return p;&#125;//释放栈link setnull(link Head)&#123; link p; p = Head; while(p != NULL)&#123; p = p -&gt; next; delete Head; Head = p; &#125; return Head;&#125;//获取栈长度int lenth(link Head)&#123; int len = 0; link p; p = Head; while(p != NULL)&#123; len++; p = p -&gt; next; &#125; return len;&#125;//获取栈顶元素int gettop(link Head)&#123; if(Head == NULL)&#123; cout&lt;&lt;\"\\n Stack is empty\\n\"; return -1; &#125;else&#123; return Head -&gt; data; &#125;&#125;//显示栈void display(link Head)&#123; link p; p = Head; if (p == NULL) &#123; cout &lt;&lt; \"\\nStack is empty\\n\"; &#125;else&#123; do&#123; cout &lt;&lt; p -&gt; data &lt;&lt; \" \"; p = p -&gt; next; &#125;while(p != NULL); &#125;&#125;//主函数int main(void)&#123;// int i, x; link head1; head1 = init(); return 0;&#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"链表","slug":"链表","date":"2019-09-30T09:48:59.000Z","updated":"2019-10-12T14:54:26.819Z","comments":false,"path":"2019/09/30/链表/","link":"","permalink":"http://yoursite.com/2019/09/30/链表/","excerpt":"","text":"用来自己学习用嘎 头文件和结构1234567891011121314151617181920212223///// main.cpp// helloworld//// Created by ljr on 2019/9/29.// Copyright © 2019 ljr. All rights reserved.//#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct List * link; //代表链表指针typedef struct List Lnode; // 代表链表节点//结构struct List&#123; ElemType data; //创一个整型为例子8 struct List * next;&#125;; 创建链表函数123456789101112131415161718192021222324252627//创建链表link create(link Head)&#123; ElemType newData; link NewPoint; Head = (link)malloc(sizeof(Lnode)); printf(\"please input number: \\n\"); scanf(\"%d\",&amp;newData); Head -&gt; data = newData; Head -&gt; next = NULL; while(true)&#123; NewPoint = (link)malloc(sizeof(Lnode)); if(NewPoint == NULL) break; printf(\"please input number: input '-1' means exit\\n\"); scanf(\"%d\",&amp;newData); if (newData == -1) &#123; return Head; &#125; NewPoint -&gt; data = newData; NewPoint -&gt; next = Head; Head = NewPoint; &#125; return Head;&#125; 显示链表123456789101112//显示链表void display(link Head)&#123; link p; p = Head; if (p == NULL) &#123; printf(\"\\nList is empty\"); &#125;else&#123; do&#123; printf(\"%d\\n\", p -&gt; data); p = p -&gt; next; &#125;while(p != NULL); &#125;&#125; 插入节点、删除节点、获取节点、查找节点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//节点插入link insert(link Head,ElemType x,int i)&#123; link NewPoint,p = Head; int j = 1; NewPoint = (link)malloc(sizeof(Lnode)); NewPoint -&gt; data = x; if(i == 1)&#123; NewPoint -&gt; next = Head; Head = NewPoint; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125; &#125; if (j == i-1) &#123; NewPoint -&gt; next = p -&gt; next; p -&gt; next = NewPoint; &#125;else&#123; printf(\"insert is failure,i si not right\"); &#125; return Head;&#125;//删除节点link del(link Head,int i )&#123; int j=1; link p,t; p = Head; if(i == 1)&#123; p = p -&gt; next; free(Head); Head = p; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125;if(p -&gt; next != NULL &amp;&amp; j == i-1)&#123; t = p -&gt; next; p -&gt; next = t -&gt; next; &#125;if(t != NULL) free(t); &#125; return Head;&#125;//获取节点元素valueElemType get(link Head,int i)&#123; int j = 1; link p; p = Head; while (j &lt; i &amp;&amp; p != NULL ) &#123; p = p -&gt; next; j++; &#125; if (p != NULL) &#123; return (p -&gt; data); &#125;else&#123; printf(\"data is error!\"); return -1; &#125;&#125;//查找节点元素x的位置int locate(link Head, ElemType x)&#123; int n = 0; link p; p = Head; while (p != NULL &amp;&amp; p -&gt; data != x) &#123; p = p -&gt; next; n++; &#125; if(p == NULL)&#123; return -1; &#125;else&#123; return n+1; &#125;&#125; 链表逆置1234567891011121314151617//链表逆置link re(link Head)&#123; link p = Head; link n = NULL,temp; //n为保存的临时第一个链表节点，temp为第二个临时节点 if(p -&gt; next == NULL)&#123; return Head; &#125; while (p != NULL) &#123; temp = p; // 设置临时变量等于头节点 p = p -&gt; next; // 让p = p的下一个节点 temp -&gt; next = n; // 让p的下一个节点指向n n第一次是NULL 后面将会等于临时变量temp n = temp; // 让n = 要逆转的节点 &#125; return n;&#125; 其它功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546//返回链表的长度int lenth(link Head)&#123; int len = 0; link p; p = Head; while(p != NULL)&#123; len++; p = p -&gt; next; &#125; return len;&#125;//链接两个链表link connect(link Head1,link Head2)&#123; link p; p = Head1; while (p -&gt; next != NULL) &#123; p = p -&gt; next; &#125; p -&gt; next = Head2; return Head1;&#125;//比较两个链表int compare(link Head1,link Head2)&#123; link p1,p2; p1 = Head1; p2 = Head2; while (true) &#123; if((p1 -&gt; next == NULL)&amp;&amp;(p2 -&gt; next == NULL)) return 1; if (p1 -&gt; data != p2 -&gt; data) &#123; return 0; &#125;else&#123; p1 = p1 -&gt; next; p2 = p2 -&gt; next; &#125; &#125;&#125;//释放链表link setnull(link Head)&#123; link p; p = Head; while (p != NULL) &#123; p = p -&gt; next; free(Head); Head = p; &#125; return Head;&#125; main函数123456789101112131415161718192021222324252627282930313233343536373839404142434445int main()&#123; int l = 0; link head1 = NULL; link head2 = NULL; head1 = create(head1); printf(\"\\nHead1 is\\n\"); display(head1); head2 = create(head2); printf(\"\\nHead2 is\\n\"); display(head2); l = compare(head1, head2); printf(\"\\nl is %d\\n\",l); connect(head1, head2); printf(\"\\nHead1 + Head2 is\\n\"); display(head1); l = lenth(head1); printf(\"\\nlenth is %d\\n\",l); l = get(head1,3); printf(\"\\nget is %d\\n\",l); l = locate(head1, 12); printf(\"\\n locate 12 is %d\",l); head1 = insert(head1, 888, 5); display(head1); head1 = del(head1, 5); display(head1); printf(\"-------------逆置前kk---------------\\n\"); display(head1); printf(\"-------------逆置后kk---------------\\n\"); head1 = re(head1); display(head1); head1 = setnull(head1); display(head1);&#125; 完整代码可直接copy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249///// main.cpp// helloworld//// Created by ljr on 2019/9/29.// Copyright © 2019 ljr. All rights reserved.//#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct List * link; //代表链表指针typedef struct List Lnode; // 代表链表节点//结构struct List&#123; ElemType data; //创一个整型为例子8 struct List * next;&#125;;//创建链表link create(link Head)&#123; ElemType newData; link NewPoint; Head = (link)malloc(sizeof(Lnode)); printf(\"please input number: \\n\"); scanf(\"%d\",&amp;newData); Head -&gt; data = newData; Head -&gt; next = NULL; while(true)&#123; NewPoint = (link)malloc(sizeof(Lnode)); if(NewPoint == NULL) break; printf(\"please input number: input '-1' means exit\\n\"); scanf(\"%d\",&amp;newData); if (newData == -1) &#123; return Head; &#125; NewPoint -&gt; data = newData; NewPoint -&gt; next = Head; Head = NewPoint; &#125; return Head;&#125;//显示链表void display(link Head)&#123; link p; p = Head; if (p == NULL) &#123; printf(\"\\nList is empty\"); &#125;else&#123; do&#123; printf(\"%d\\n\", p -&gt; data); p = p -&gt; next; &#125;while(p != NULL); &#125;&#125;//节点插入link insert(link Head,ElemType x,int i)&#123; link NewPoint,p = Head; int j = 1; NewPoint = (link)malloc(sizeof(Lnode)); NewPoint -&gt; data = x; if(i == 1)&#123; NewPoint -&gt; next = Head; Head = NewPoint; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125; &#125; if (j == i-1) &#123; NewPoint -&gt; next = p -&gt; next; p -&gt; next = NewPoint; &#125;else&#123; printf(\"insert is failure,i si not right\"); &#125; return Head;&#125;//删除节点link del(link Head,int i )&#123; int j=1; link p,t; p = Head; if(i == 1)&#123; p = p -&gt; next; free(Head); Head = p; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125;if(p -&gt; next != NULL &amp;&amp; j == i-1)&#123; t = p -&gt; next; p -&gt; next = t -&gt; next; &#125;if(t != NULL) free(t); &#125; return Head;&#125;//获取节点元素valueElemType get(link Head,int i)&#123; int j = 1; link p; p = Head; while (j &lt; i &amp;&amp; p != NULL ) &#123; p = p -&gt; next; j++; &#125; if (p != NULL) &#123; return (p -&gt; data); &#125;else&#123; printf(\"data is error!\"); return -1; &#125;&#125;//查找节点元素x的位置int locate(link Head, ElemType x)&#123; int n = 0; link p; p = Head; while (p != NULL &amp;&amp; p -&gt; data != x) &#123; p = p -&gt; next; n++; &#125; if(p == NULL)&#123; return -1; &#125;else&#123; return n+1; &#125;&#125;//返回链表的长度int lenth(link Head)&#123; int len = 0; link p; p = Head; while(p != NULL)&#123; len++; p = p -&gt; next; &#125; return len;&#125;//链接两个链表link connect(link Head1,link Head2)&#123; link p; p = Head1; while (p -&gt; next != NULL) &#123; p = p -&gt; next; &#125; p -&gt; next = Head2; return Head1;&#125;//比较两个链表int compare(link Head1,link Head2)&#123; link p1,p2; p1 = Head1; p2 = Head2; while (true) &#123; if((p1 -&gt; next == NULL)&amp;&amp;(p2 -&gt; next == NULL)) return 1; if (p1 -&gt; data != p2 -&gt; data) &#123; return 0; &#125;else&#123; p1 = p1 -&gt; next; p2 = p2 -&gt; next; &#125; &#125;&#125;//释放链表link setnull(link Head)&#123; link p; p = Head; while (p != NULL) &#123; p = p -&gt; next; free(Head); Head = p; &#125; return Head;&#125;//链表逆置link re(link Head)&#123; link p = Head; link n = NULL,temp; //n为保存的临时第一个链表节点，temp为第二个临时节点 if(p -&gt; next == NULL)&#123; return Head; &#125; while (p != NULL) &#123; temp = p; // 设置临时变量等于头节点 p = p -&gt; next; // 让p = p的下一个节点 temp -&gt; next = n; // 让p的下一个节点指向n n第一次是NULL 后面将会等于临时变量temp n = temp; // 让n = 要逆转的节点 &#125; return n;&#125;int main()&#123; int l = 0; link head1 = NULL; link head2 = NULL; head1 = create(head1); printf(\"\\nHead1 is\\n\"); display(head1); head2 = create(head2); printf(\"\\nHead2 is\\n\"); display(head2); l = compare(head1, head2); printf(\"\\nl is %d\\n\",l); connect(head1, head2); printf(\"\\nHead1 + Head2 is\\n\"); display(head1); l = lenth(head1); printf(\"\\nlenth is %d\\n\",l); l = get(head1,3); printf(\"\\nget is %d\\n\",l); l = locate(head1, 12); printf(\"\\n locate 12 is %d\",l); head1 = insert(head1, 888, 5); display(head1); head1 = del(head1, 5); display(head1); printf(\"-------------逆置前kk---------------\\n\"); display(head1); printf(\"-------------逆置后kk---------------\\n\"); head1 = re(head1); display(head1); head1 = setnull(head1); display(head1);&#125; 2019.10.09 增加递归逆置链表；123456789101112131415161718192021222324252627282930313233343536373839404142//测试代码如下#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct List * link; //代表链表指针typedef struct List Lnode; // 代表链表节点//结构struct List&#123; ElemType data; //创一个整型为例子8 struct List * next;&#125;;List * reverseList(List * Head)&#123; //如果链表为空或者链表中只有一个元素 if (Head -&gt; next == NULL || Head == NULL) &#123; return Head; &#125;else&#123; List * newHead = reverseList(Head -&gt; next); //先反转后面的链表 Head -&gt; next -&gt; next = Head; //再将当前节点设置为其然来后面节点的后续节点 Head -&gt; next = NULL; return newHead; &#125;&#125;int main()&#123; link head1 = NULL; head1 = create(head1); printf(\"\\nHead1 is\\n\"); printf(\"-------------逆置前kk---------------\\n\"); display(head1); printf(\"-------------逆置后kk---------------\\n\"); head1 = reverseList(head1); display(head1);&#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"git","slug":"git","date":"2019-09-29T09:48:19.000Z","updated":"2019-10-12T15:30:53.488Z","comments":false,"path":"2019/09/29/git/","link":"","permalink":"http://yoursite.com/2019/09/29/git/","excerpt":"","text":"记一次小作业默认已经下载git第一步先生成ssh秘钥吧哈哈哈哈，具体创建方法看下面的网址8。 https://blog.csdn.net/lucky__yang/article/details/80148420 好了后就开始创建个仓库8.不会创建？那看这个，看到创建完仓库8. https://blog.csdn.net/qq_35869389/article/details/79472564 再在本地计算机中创建一个test文件夹 随便打点东西在cpp中 进入文件夹后再Git中输入init 再输入git status查看文件下都有什么文件 利用 git add main.cpp添加文件在打一次Git status就会有绿色的文件表示成功 最后成功","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"from表单提交检测","slug":"from表单提交检测","date":"2019-09-21T09:46:56.000Z","updated":"2019-10-12T14:54:40.883Z","comments":false,"path":"2019/09/21/from表单提交检测/","link":"","permalink":"http://yoursite.com/2019/09/21/from表单提交检测/","excerpt":"","text":"以前一直认为form是只能直接提交数据的，直到今天突然发现先看看一个简单的html代码：一个简单的提交没什么的 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"login.css\" type=\"text/css\"&gt; &lt;script type=\"text/javascript\" src=\"jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"login.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"loginBigArea\" &gt; &lt;div class=\"loginInsideArea\"&gt; &lt;form id=\"loginForm\" action=\"login\"&gt; &lt;div class=\"loginTitle\"&gt;登录&lt;/div&gt; &lt;input type=\"text\" placeholder=\"学号\" class=\"scanf\" id=\"stuNum\"&gt;&lt;br&gt; &lt;input type=\"password\" placeholder=\"密码\" class=\"scanf\" id=\"pwd\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"subBut\"&gt;&lt;br&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在来看看js中的代码 12345678910111213141516171819202122232425262728293031323334function checkStuNum() &#123; var num = $(\"#stuNum\").val(); var reg_num = /^\\w&#123;8&#125;$/; var flag = reg_num.test(num); if(flag)&#123; $(\"#stuNum\").css(\"border\",\"1px solid #5eb6de\"); &#125;else&#123; $(\"#stuNum\").css(\"border\",\"1px solid red\"); &#125; return flag; //这里返回的数据如果是false，那表单将不会提交&#125;function checkPwd() &#123; var pwd = $(\"#pwd\").val(); var reg_pwd = /^\\w&#123;6,20&#125;$/; var flag = reg_pwd.test(pwd); if(flag)&#123; $(\"#pwd\").css(\"border\",\"1px solid #5eb6de\"); &#125;else&#123; $(\"#pwd\").css(\"border\",\"1px solid red\"); &#125; return flag; //这里返回的数据如果是false，那表单将不会提交&#125;$(function () &#123; //当表单提交时调用所有校验方法 $(\"#loginForm\").submit(function () &#123; return checkStuNum() &amp;&amp; checkPwd(); &#125;); //当鼠标失去焦点，调用校验方法 $(\"#stuNum\").blur(checkStuNum); $(\"#pwd\").blur(checkPwd);&#125;) 是的，这样做之后，表单会在检测之后才提交！！！可能是我没好好学js的原因吧，才知道可以这样子。","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"ajax","slug":"ajax","date":"2019-09-21T09:45:52.000Z","updated":"2019-10-12T14:54:33.978Z","comments":false,"path":"2019/09/21/ajax/","link":"","permalink":"http://yoursite.com/2019/09/21/ajax/","excerpt":"","text":"自己遇到的小问题 ajax提交后获取不到数据#2019/05/26 123456&lt;form id=\"loginForm\" action=\"../checkLoginServlet\"&gt;&lt;div class=\"loginTitle\"&gt;登录&lt;/div&gt;&lt;input type=\"text\" placeholder=\"学号\" class=\"scanf\" id=\"stuNum\"&gt;&lt;br&gt;&lt;input type=\"password\" placeholder=\"密码\" class=\"scanf\" id=\"pwd\" &gt;&lt;br&gt;&lt;input type=\"submit\" class=\"subBut\"&gt;&lt;br&gt;&lt;/form&gt; 提交不到数据时我是这样写的 1234567//后来才知道，表单序列化 都是user=xxx&amp;xxx 这种格式，所以需要在&lt;input&gt;标签中添加一个name，才能序列号 &lt;form id=\"loginForm\" action=\"../checkLoginServlet\"&gt; &lt;div class=\"loginTitle\"&gt;登录&lt;/div&gt; &lt;input type=\"text\" placeholder=\"学号\" class=\"scanf\" id=\"stuNum\" name=\"stuNum\"&gt;&lt;br&gt; &lt;input type=\"password\" placeholder=\"密码\" class=\"scanf\" id=\"pwd\" name=\"pwd\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"subBut\"&gt;&lt;br&gt; &lt;/form&gt;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"js转jquery","slug":"js转jquery","date":"2019-09-21T09:44:23.000Z","updated":"2019-10-12T14:55:00.387Z","comments":false,"path":"2019/09/21/js转jquery/","link":"","permalink":"http://yoursite.com/2019/09/21/js转jquery/","excerpt":"","text":"js对象转换成jquery对象#2019/05/26 123456789//serialize() 方法通过序列化表单值，创建 URL 编码文本字符串。//你可以选择一个或多个表单元素（比如 input 及/或 文本框），或者 form 元素本身。//序列化的值可在生成 AJAX 请求时用于 URL 查询字符串中。$(\"form\").serialize()//输出后会变成a=1&amp;b=2&amp;c=3&amp;d=4&amp;e=5","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"docker","slug":"docker","date":"2019-09-19T09:42:48.000Z","updated":"2019-10-12T14:54:37.448Z","comments":false,"path":"2019/09/19/docker/","link":"","permalink":"http://yoursite.com/2019/09/19/docker/","excerpt":"","text":"docke的基本使用:容器的创建还有镜像的下载看网址就好：1https://www.runoob.com/docker/docker-install-tomcat.html 常用命令大全： 先了解下基础操作命令 镜像: 应用程序所依赖的操作环境和配置形成的模板，用面向对象的话来说简称类 容器: 通过镜像来运行容器，容器相当于类的实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576ip addr/ip link/ ifconfig：查看宿主机里ip地址（宿主机表示是虚拟机)systemctl start docker/service start docker：启动docker服务systemctl stop docker:关闭docker服务service iptables start:启动防火墙service iptables restart:重启防火墙service iptables stop:关闭防火墙docker run：启动containerdocker seach xxxx(镜像名称):检索镜像docker pull xxx(镜像名称）：拉取镜像docker images:列出镜像docker --version:查看docker的版本信息[root@localhost ~]:家目录[root@localhost /]:根目录docker exec Container Id:进入容器docker exec -it NAMES(自定义名称) /bin/bash:进入--name命名的容器docker exec NAMES(容器的自定义名称）-it bash:进入容器里进行操作docker attach Container Id:进入到容器的终端docker inspect IMAGE ID:显示容器或镜像的元数据[root@（container id）]：比如[root@24527d42d3eb]表示已进入docker里的一个CONTAINER ID的容器内部[root@24527d42d3eb]:exit(从容器里退出）。docker ps：查看docker里运行的容器（status为Up....表示运行中）docker ps -a:查看docker里已停止或正在运行的容器（status为Exit)docker start CONTAINER ID ：如果容器的状态为Exit,用它来启动容器docker stop CONTAINER ID :停止正在运行的容器，删除一个容器必须先要停止docker restart :当部署web项目的war文件，到tomcat里的webapps里面了，重启一下docker服务，就自动解压了war文件docker rm CONTAINER ID ：删除容器docker rm $(docker ps -a -q)：删除所有已停止的容器;docekr rmi IMAGE ID:删除镜像rm -rf xxxx：强制删除某个war.文件或目录、文件docker cp /xxx.war CONTAINER ID :/usr/local/tomcat/webapps：从/根目录复制一个打包后的Java web war文件 到tomcat容器里的webapps工作目录里docker exec CONTAINER ID ls /usr/local/tomcat:默认的 安装tomcat镜像的webapps目录docker run -name xxx -p (自定义端口号,用来访问的):(容器的端口号：比如tomcat的8080，mysql的3306） -d docker.io/tomcat(镜像名称)：表示在docker里运行一个tomcat容器,如果没有镜像，自动pull一个tomcat的镜像--name 为容器取一个名字-p 容器要映射的端口号-d:后台运行-t：进入终端-i：获得一个交互式的连接，通过获取container的输入/bin/bash：在container中启动一个bash shell 因为我只在docker中建立了tomcat的和mysql两个环境，所以这里就只讲讲tomcat和mysql的创建： 开始安装tomcat1234567891011输入这条命令docker run --name tomcat -p 8080:8080 -d tomcat在用docker ps查看的时候显示的是eee4f17b3f78 tomcat \"catalina.sh run\" 15 seconds ago Up 14 seconds 0.0.0.0:8080-&gt;8080/tcp tomcat默认是0.0.0.0:8080登录这个网址就会出现tomcat主页127.0.0.1:8080不行，就去百度了一下端口映射的问题然后发现在创建的时候用这条语句之后就可以访问了将本机的端口映射过去了，在本机浏览器中输入127.0.0.1:8080或localhost:8080既可docker run --name tomcat -p 127.0.0.1:8080:8080 -d tomcat mysql的话12345这条语句就搞定了 其中的东西自己配置docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7然后输入docker exec -it mysql /bin/bashmysql -uroot -p123456 测试成功；就Vans了","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"scrapy","slug":"scrapy","date":"2019-09-18T09:38:44.000Z","updated":"2019-10-12T14:55:04.208Z","comments":false,"path":"2019/09/18/scrapy/","link":"","permalink":"http://yoursite.com/2019/09/18/scrapy/","excerpt":"","text":"Scrapy框架的安装先pip install wheel,在去 1https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载 1lxml‑4.3.4‑cp36‑cp36m‑win_amd64.whll 注意根据型号什么的下载，然后再 1pip install 下载的文件地址 然后再去 1https://pypi.org/project/pyOpenSSL/#downloads 下载 1pyOpenSSL-19.0.0-py2.py3-none-any.whl 继续 1https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载 1twain‑1.0.4‑cp36‑cp36m‑win_amd64.whl 继续 1https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/ 下载 12pywin32-221.win-AMD64-py3.6.exe (这个我没找到最后用pip install pywin32成功安装的溜了溜了。) 遇到了各种问题，我累了，懒得一一列出来 scrapy调试工具命令行中输入 1scrapy shell http://lab.scrapyd.cn scrapy shell 固定格式，后面的话跟的是你要调试的页面，如果是百度就： 1scrapy shell (http://www.baidu.com)(URL可改变) 就这样一个格式，其实这段代码就是一个下载的过程，一执行这么一段代码scrapy就立马把我们相应链接的相应页面给拿到了，那接下来就可以任你处置了。 在要提前的调试界面In中输入 1response.css('title') 之类的语句就可以自动调试了 scrapy框架的基本使用在需要创建的目录下打开cmd 1然后输入 scrapy startproject /项目名称/. 在输入需要爬取的URL进入创建的目录下 1输入 scrapy genspider quotes /URL/. 这里也可以手动创建一个python文件，同理: 12345678910111213141516171819202122232425262728293031323334import scrapyclass mingyan(scrapy.Spider): #需要继承scrapy.Spider类 name = \"mingyan2\" # 定义蜘蛛名 def start_requests(self): # 由此方法通过下面链接爬取页面 # 定义爬取的链接 urls = [ 'http://lab.scrapyd.cn/page/1/', 'http://lab.scrapyd.cn/page/2/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) #爬取到的页面如何处理？提交给parse方法处理 def parse(self, response): ''' start_requests已经爬取到页面，那如何提取我们想要的内容呢？那就可以在这个方法里面定义。 这里的话，并木有定义，只是简单的把页面做了一个保存，并没有涉及提取我们想要的数据，后面会慢慢说到 也就是用xpath、正则、或是css进行相应提取，这个例子就是让你看看scrapy运行的流程： 1、定义链接； 2、通过链接爬取（下载）页面； 3、定义规则，然后提取数据； 就是这么个流程，4不4很简单呀？ ''' page = response.url.split(\"/\")[-2] #根据上面的链接提取分页,如：/page/1/，提取到的就是：1 filename = 'mingyan-%s.html' % page #拼接文件名，如果是第一页，最终文件名便是：mingyan-1.html with open(filename, 'wb') as f: #python文件操作，不多说了； f.write(response.body) #刚才下载的页面去哪里了？response.body就代表了刚才下载的页面！ self.log('保存文件: %s' % filename) # 打个日志 scrapy css选择器的使用12输入response.css('title')可以得到[&lt;Selector xpath='descendant-or-self::title' data='&lt;title&gt;xxxxxxxxxxxxxxxxx&lt;/title&gt;'&gt;]类似的东西 如果你加上 1234567891011response.css('title').extract()这个他就会变成['&lt;title&gt;xxxxxxxxxxx&lt;/title&gt;']列表的形式，如果不需要列表可以这样。response.css('title').extract_first()，那么爬下来的数据为这样 '&lt;title&gt;xxxxxxxxxxx&lt;/title&gt;' extract_first()就代表提取第一个元素（我想这个谁都看得出来） 当然如果你觉得怎么多了个title标签 那你可以这样： response.css('title::text').extract_first() 这样爬下来的数据就是xxxxxxxxxxx了 我们该如何提取URL呢？提取属性我们是用：“标签名::attr(属性名)”，比如我们要提取url表达式就是：a::attr(href)，要提取图片地址的表达式就是：img::attr(src)……以此类推：获取所有a标签下的所以href 1response.css(\"a::attr(href)\") 获取固定class样式下的标签 1response.css(\".page-navigator a::attr(href)\").extract() 如果是src那就要这样写 1response.css(\".xxxx img::attr(src)\").extract() 还有好多,自己发挥。 xpath提取数据123456nodename = 选取此节点的所有子节点。/ = 从根节点选取。// = 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。. = 选取当前节点。.. = 选取当前节点的父节点。@ = 选取属性。 response.xpath(“表达式”)，提取属性的话既然使用：@，那我们要提取href就是：@href 12In: response.xpath(\"@href\")out: [] 可以看到输出为0,因为我们木有限定从哪里提取,一般我们都需要加个：//，再来试试 1234567891011121314In: response.xpath(\"//@href\")out: [&lt;Selector xpath='//@href' data='//cdnjscn.b0.upaiyun.com/libs/normalize/'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/usr/themes/default'&gt;, …… &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E7%8E%8B%E5%B'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E6%99%BA%E6%8'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E6%B3%B0%E6%8'&gt;,…… &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E8%AF%8D/'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn'&gt;, &lt;Selector xpath='//@href' data='http://bbs.scrapyd.cn'&gt;, &lt;Selector xpath='//@href' data='http://www.scrapyd.cn'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/'&gt;] 已经提取到了，只是这是这个页面所有的href，并非是我们想要的，那和css选择一样我们需要加以限制.例如一个ol标签下 123456789In: response.xpath(\"//ol//@href\")Out:[&lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/1/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/2/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/3/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/4/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/6/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/2/'&gt;] “//ol//@href”，这个表达式表示：ol标签下所有的href属性值，可以看到我们这里限定了html的ol标签，这里的话页面只有一个ol，不会出错，如果页面中有多个ol，那就不一定能得到我们想要的结果,这里我们还能限定我们的属性，使用的是：标签[@属性名=’属性值’]； 例如： 123&lt;ol class=\"page-navigator\"&gt; ……&lt;/ol&gt; 里面有个：class=“page-navigator”，那我们就可以这样限制：//ol[@class=”page-navigator”]//@href 好了，这样的话就能让ol尽量缩小范围，我们再来试试这个代码效果： 1234567891011121314In : response.xpath(\"//ol[@class='page-navigator']//@href\")Out:[&lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/1/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/2/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/3/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/4/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/6/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/2/'&gt;] 可以看到也是同样得到想要的效果，以此类推，可以根据自己的情况来缩小范围如果这里的属性是id那就：ol[@id=’page-navigator’]和css选择器一样，xpath中也有extract（）、extract_first()这两个函数，加上就可以提取纯粹的href值了 ——————————–分割 接下来我们提取标签里面的内容，表达式： //text()，其实就是提取文本（不想说了，放个例子你们会懂得） 12In : response.xpath(\"//title//text()\").extract()Out: ['xxxxxxxxxxx'] 可以看到，表达式为：//title//text() ，就是用到了：//text() 这个表达式，前面的：//title是限定你要提取的范围，同理如果你要提取首页右侧的标签，如下： 12345678910111213141516171819&lt;ul class=\"tags-list\"&gt; &lt;li&gt;&lt;a style=\"color:rgb(101,86, 72)\" href=\"http://lab.scrapyd.cn/tag/%E4%BA%BA%E7%94%9F/\"&gt; 人生&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a style=\"color:rgb(214,236, 5)\" href=\"http://lab.scrapyd.cn/tag/%E5%8A%B1%E5%BF%97/\"&gt; 励志&lt;/a&gt;&lt;/li&gt; …… &lt;li&gt;&lt;a style=\"color:rgb(4,4, 41)\" href=\"http://lab.scrapyd.cn/tag/%E7%BB%9D%E4%B8%96%E5%A5%BD%E8%AF%8D/\"&gt; 绝世好词&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a style=\"color:rgb(204,12, 225)\" href=\"http://lab.scrapyd.cn/tag/%E6%9C%A8%E5%BF%83/\"&gt; 木心&lt;/a&gt;&lt;/li&gt; …… &lt;li&gt;&lt;a href=\"http://lab.scrapyd.cn\"&gt;返回首页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"http://bbs.scrapyd.cn\" target=\"_blank\"&gt;SCRAPY中文社区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.scrapyd.cn\" target=\"_blank\"&gt;SCRAPY中文网&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 可以看到标签文字是在 “class=tags-list” 的ul里面，那我们就可以这样写表达式：//ul[@class=’tags-list’]//a//text()，具体代码如下： 1234567891011121314151617In [5]: response.xpath(\"//ul[@class='tags-list']//a//text()\").extract()Out[5]:['\\r\\n 人生', '\\r\\n 励志', '\\r\\n 爱情', '\\r\\n 王尔德', '\\r\\n 智慧', '\\r\\n 泰戈尔', '\\r\\n 绝世好词', '\\r\\n 木心', '\\r\\n 艺术', '\\r\\n 名画', '\\r\\n 生活', '\\r\\n 词', '返回首页', 'SCRAPY中文社区', 'SCRAPY中文网'] 可以看到经过这样的限制，我们就定位到了； ——————–分割线 包含HTML标签的所有文字内容提取：string() 如果我们用表达式：//div[@class=’post-content’]//text()，你会发现虽然能提取但是一个列表，不是整段文字：那这里我们就用到一个xpath函数：string()，我们可以把表达式这样写：response.xpath(“string(//div[@class=’post-content’])”).extract()，可看到我们没有使用：text()，而是用：string(要提取内容的标签)，这样的话就能把数据都提取出来了，而且都合成为一条。","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-17T05:38:44.000Z","updated":"2019-10-12T14:54:54.856Z","comments":false,"path":"2019/09/17/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/17/hello-world/","excerpt":"","text":"note很久前就想自己搭个博客，当时想自己手写前端后端，终于在最后放弃了(Hexo真香)这里我就放平时自己做做的菜鸡笔记还有一些自己遇到的弱鸡问题好了 1$ My first note","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]}