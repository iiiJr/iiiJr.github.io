{"meta":{"title":"小胖","subtitle":"写点什么","description":null,"author":"Jr'Blog","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-10-12T00:47:01.000Z","updated":"2019-10-12T15:45:53.060Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"孩儿立志出乡关，学不成名誓不还。"},{"title":"categories","date":"2019-10-11T15:14:13.000Z","updated":"2019-10-12T15:45:44.462Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-11T15:17:40.000Z","updated":"2019-10-12T15:45:48.986Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"trainingDiary_3","slug":"daily3","date":"2019-12-16T15:33:17.000Z","updated":"2019-12-16T15:33:18.361Z","comments":false,"path":"2019/12/16/daily3/","link":"","permalink":"http://yoursite.com/2019/12/16/daily3/","excerpt":"","text":"2019-12-16-继续建立一个基于fabric网络的demo写在前面昨天晚上大概发现了自己没有上面东西所以创建不了新的网络demo，所以今天继续跟着问题寻找下去（漫无目的），今天继续试着搭建网络。 重新搭建环境今天一早醒来的第一件事就是给原来的环境拍了个快照，然后重新还原到初始快照，又搭建了一次整个fabric框架，搭建过程我就不复述了，网上很多教程，我是看着这个搭建的。 1https://www.jianshu.com/p/0ec409f77fb3 重新搭建环境又是一大堆乱七八糟的报错，东整整西搞搞，一早上就这样过去了，好在终于把初始环境搭建好了。 简单的事例在百度上找到了个fabric-samples的项目，是个测试项目，所以就跟着搭建了。博客地址在这。 1https://blog.csdn.net/qq_36956154/article/details/82317514 跟着它的搭建，我被卡在了这一步，也报了错，首先是调用一个cryptogen工具来生成各种网络实体加密材料。这里调用了跟他报了一样的错，然后他的下一步是在网上拉项目下来，我就在这里卡住了。 这是跟他一样情况的报错 123456[root@localhost first-network]# bash byfn.sh -m generateGenerating certs and genesis block for with channel &apos;mychannel&apos; and CLI timeout of &apos;10000&apos;Continue (y/n)? yproceeding ...which: no cryptogen in (/opt/gopath/src/github.com/hyperledger/fabric-samples/first-network/../bin:/opt/gopath/src/github.com/hyperledger/fabric-samples/first-network:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)cryptogen tool not found. exiting 然后是拉项目，在这里时，它拉不下来，一直报错。开始百度。 123456iiijr@iiijr-virtual-machine:~/go/src/github.com/hyperledger/fabric-samples/bin$ ./get-byfn.sh ===&gt; Downloading Build Your First Network sample application./get-byfn.sh: 行 13: VERSION: 未找到命令 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 995 0 995 0 0 333 0 --:--:-- 0:00:02 --:--:-- 333 我在查了各种资料，也翻了很多博客后，最后去这个地址看了下。我发现！！，根本没有这个文件，它换了地址！！！然后我跟着他换了地址。终于，它开始拉了！！然后我发现了新的问题，它拉的，实在是太慢了，我不清楚是网络问题还是什么问题。 12345iiijr@iiijr-virtual-machine:~/go/src/github.com/hyperledger/fabric-samples/bin$ curl https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/linux-amd64-1.0.0/hyperledger-fabric-linux-amd64-1.0.0.tar.gz | tar xz % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 1 22.5M 1 387k 0 0 3017 0 2:10:45 0:02:11 2:08:34 0curl: (56) GnuTLS recv error (-54): Error in the pull function. 它拉了整整两个钟！！！这期间我一直在找别的源文件或者其他人已经下载过的文件，发现都没什么用，最后耐心等待。 终于它拉完了。我在我的ubuntu下文件目录下看到了bin，太激动了。马上开始下一步，执行脚本。新的开始，新的报错 1234567891011121314151617181920212223242526272829303132333435363738394041iiijr@iiijr-virtual-machine:~/go/src/github.com/hyperledger/fabric-samples/first-network$ bash byfn.sh -m generate Generating certs and genesis block for channel &apos;mychannel&apos; with CLI timeout of &apos;10&apos; seconds and CLI delay of &apos;3&apos; secondsContinue? [Y/n] yproceeding .../home/iiijr/go/src/github.com/hyperledger/fabric-samples/first-network/../bin/cryptogen############################################################### Generate certificates using cryptogen tool ###################################################################+ cryptogen generate --config=./crypto-config.yamlorg1.example.comorg2.example.com+ res=0+ set +xGenerate CCP files for Org1 and Org2/home/iiijr/go/src/github.com/hyperledger/fabric-samples/first-network/../bin/configtxgen################################################################### Generating Orderer Genesis block ########################################################################2019-12-16 18:46:22.296 CST [common/configtx/tool] main -&gt; INFO 001 Loading configuration2019-12-16 18:46:22.315 CST [common/configtx/tool/localconfig] Load -&gt; CRIT 002 Error unmarshaling config into struct: 17 error(s) decoding:* &apos;&apos; has invalid keys: capabilities, channel* &apos;Application&apos; has invalid keys: Capabilities, Policies* &apos;Orderer&apos; has invalid keys: Policies* &apos;Organizations[0]&apos; has invalid keys: Policies* &apos;Organizations[1]&apos; has invalid keys: Policies* &apos;Organizations[2]&apos; has invalid keys: Policies* &apos;Profiles[SampleMultiNodeEtcdRaft]&apos; has invalid keys: Capabilities, Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Application&apos; has invalid keys: Capabilities, Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Application.Organizations[0]&apos; has invalid keys: Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Consortiums[SampleConsortium].Organizations[0]&apos; has invalid keys: Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Consortiums[SampleConsortium].Organizations[1]&apos; has invalid keys: Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Orderer&apos; has invalid keys: Capabilities, EtcdRaft, Policies* &apos;Profiles[SampleMultiNodeEtcdRaft].Orderer.Organizations[0]&apos; has invalid keys: Policies* &apos;Profiles[TwoOrgsChannel]&apos; has invalid keys: Capabilities, Policies* &apos;Profiles[TwoOrgsChannel].Application&apos; has invalid keys: Capabilities, Policies* &apos;Profiles[TwoOrgsChannel].Application.Organizations[0]&apos; has invalid keys: Policies* &apos;Profiles[TwoOrgsChannel].Application.Organizations[1]&apos; has invalid keys: PoliciesFailed to generate orderer genesis block... 执行了脚本后，它报了这些错。我去百度了下，他们说的意思大概是说，我刚刚拉了两个小时拉下来的文件版本和这个fabric框架环境不符，已经崩溃。 开心找对应版本，是的，我又找到了对应版本，决定重拉一次，又等了无数时间，然后又执行了一次，然后还是同样的错误。然后我就一直卡在这一步，查找了各种资料，换了无数版本，重新搭建了无数次环境，可它还是不行。泪奔。。。还是要跟着书记来系统学比较现实，书籍到了，刚刚翻了几页，看了一下搭建环境啥的，没发现有什么大问题，决定明天好好跟着书籍来一遍，今天已经崩溃，洗个澡先，开溜。","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"trainingDiary_2","slug":"daily2","date":"2019-12-15T12:26:17.000Z","updated":"2019-12-15T13:18:05.155Z","comments":false,"path":"2019/12/15/daily2/","link":"","permalink":"http://yoursite.com/2019/12/15/daily2/","excerpt":"","text":"2019-12-15-建立一个基于fabric网络的demo（然而并没有成功）写在前面昨天看了sdk的基本包应用和了解了fabirc框架的一些部分节点组织通道之类的作用，但是也还没继续深入（这个先交给我的好队友吧），今天想先试着搭建一个新的网络demo并写一下基本的账户管理，可是我发现我并没搭出来。 问题：1:今天去网上可以说是搜了一整天的资料，太零零碎碎了，说的也不大仔细（可能是我太菜了），他们的做法都是先独立创建一个目录文件，我也跟着它创建了： 12mkdir -p $GOPATH/src/github.com/hyperledger/fabric-democd $GOPATH/src/github.com/hyperledger/fabric-demo 可是，创建完后，我就傻了，据博客所说，它上面有配置文件，它说先初始化容器，我初始化了，然后！然后生产节点PKI文件和创世块等基础配置，它是直接打了这两个命令！课我没有这个generate.sh啊！！！ 12cd basic-network/./generate.sh 好的，开始研究，它是哪来的，它说了一段话，说这是它写好的配置文件，可它没说写哪，我就自己找了下，发现它博客下面有github项目地址，配置文件是在那里，我就把它给考进了我的ubuntu中 1git clone https://github.com/wesker8088/fabric-account.git clone下来后，我将它放进我的文件夹中，然后运行它，它就报错了， 1./generate.sh: 16: ./generate.sh: cryptogen: not found Failed to generate crypto material... 翻译是未生成加密材料这个我也不知道是什么错，然后又开始找错误。网上找到的问题解答，各种各样，我也试了很多种，没有一种是可以的。也觉得很奇怪，不明白为什么，我就去看了fabric的中文文档，看看可不可以看出什么来。然后我就发现了，文档的环境搭建,因为我是搭建完成了环境的，我就接着他搭建完环境的步骤继续走下去，它上面写了个工具，叫configtxgen，它的作用是生成两个内容： Orderer的bootstrap block和Fabric的channel configuration transaction。然后我就在我搭建好的环境里，找这个工具，然而并没有找到。没有找到我也就先跳过了，在后面继续看别的，文档说它为了给我们方便使用，给了我们一个脚本，这脚本叫generateCfgTrx.sh，意思就是整合了上面的工具，帮我门生成那两个内容，然而我也没有这个脚本，至于为什么这些脚本为什么都没有，我也不是很清楚，可能是因为fabric版本不一样，也可能是安装环境是出现了我不知道的错误，所以我就继续往后看。文档中有一段，教我们怎么搭建第一个网络，我点进去看了，它说在例子中有一个脚本，可以帮助你快速搭建一个网络，然后，我这个脚本也没用，它叫byfn.sh。又开始了百度之旅，我搜的是fabric文件例子中为什么没有byfn.sh这个脚本，结果出来的百度，只有运行它之后为什么报错，好像没有人没遇到我这个情况，在加上百度资料也少，（人也快傻了）害！！！","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"trainingDiary_1","slug":"日记","date":"2019-12-14T06:38:13.000Z","updated":"2019-12-15T13:19:53.517Z","comments":false,"path":"2019/12/14/日记/","link":"","permalink":"http://yoursite.com/2019/12/14/日记/","excerpt":"","text":"2019-12-14-Fabric SDK写在前面关于框架的环境搭建已经完成，但是对整个框架的操作原理自己还是没摸清楚，在加上go语言也只是刚刚接触，还不是很能熟它的各种代码，因为队友是弄系统的，所以我不打算先深入到摸透整个框架，和队友分工，我先学开发那一块，他先深入，我们在一起互相学习，想了很多方案，不知道该从哪里入手好，因为对于整个框架还不是很熟悉，所以没急着先去弄智能合约什么的就先从框架开放的sdk入手了，sdk是一定要熟练的，如果对它都不熟悉，开始写代码可能报个错都要查半天，所以就从sdk先入手了。至于启动整个生鲜的项目的话还不怎么着急。先把go和sdk玩熟了后在开始去启动项目，看源码，学习一整个框架，必须先把基础打好，才能开始写代码。 Fabric SDK简介今天由于早上和下午都教学楼都是考试也进不去，只能在宿舍用手机看下部分sdk简介，晚上才过来开始查看整个sdk文档。简介大概说的就是：Farbric的Peer节点和Orderer节点都提供了基于gRPC协议的接口，用于和Peer节点与Orderer节点进行命令/数据交互。为了简化开发，为开发人员开发应用程序提供操作Fabric区块链网络的API，Fabric官方提供了多种语言版本的SDK。其中就有go的sdk（这里原本不知道gRPC是什么意思，查了后发现gRPC是用来指定一个可以远程调用的带有参数和返回类型的的方法。在服务端，服务实现这个接口并且运行gRPC服务处理客户端调用。在客户端，有一个stub提供和服务端相同的方法。）其实简单来说就是一个拿来服务端和客户端通信和简化通信系统的构建的，但记住它支持多种语言，基于http/2标准设计。 回到正题，fabric中可以通过SDK访问Fabric网络中的多种资源，包括账本、交易、链码、事件、权限管理等，应用程序代表用户与Fabric网络进行交互，Fabric SDK API提供了如下功能：A、创建通道B、将peer节点加入通道C、在peer节点安装链码D、在通道实例化链码E、通过链码调用交易F、查询交易或区块的账本 安装的话他是给出了fabric sdk 就在github上： 1go get -u github.com/hyperledger/fabric-sdk-go关于sdk的源码结构，其实就是说说包中的功能 123456pkg/fabsdk: Fabric SDK的主要包，允许基于配置创建上下文。上下文由客户端软件包使用。pkg/client/channel: 提供通道交易相关功能pkg/client/event: 提供通道事件相关功能pkg/client/ledger: 启用对通道底层账本的查询相关功能pkg/client/resmgmt: 提供资源管理功能，例如安装链码pkg/client/msp: 启用身份管理相关功能Fabric SDK功能模块API：对于应用开发者来说，插件化的API可以支持SDK提供的关键接口的可选实现。对于每个接口，都有内置的默认实现，也可以灵活自定义。（意思就是说有内置的包，但是当然你也可以自己实现） Fabric-client:这个包的话提供的API是框架的网络核心组件，就是对peer，order这些节点的进行交互。功能的话包括（创建channel，请求peer节点加入channel，在peer安装chaincode，在channel中实例化chaincode，调用chaincode来调用食物，查询分类账的事物或块等） 这里解释一下： peer：fabric网络中的节点，意思是一个运行这的docker容器，可以和网络中的其他peer进行通信，peer可以分为两种类型： endorsing peer/endorser：安装和执行chaincode等一系列操作都离不开peer，我们通常会说将chaincode安装在某个peer上。它既可以是模拟chaincode执行的endorser也可以是验证背书策略是否满足条件的 endorsing peer：安装和执行chaincode等一系列操作都离不开peer，我们通常会说将chaincode安装在某个peer上。它既可以是模拟chaincode执行的endorser也可以是验证背书策略是否满足条件的endorsing peer。 anchor peer被称为锚节点。作为一个channel或org的代表，从orderer获取信息，并且组内广播给其他peer。其他peer可以不直接跟orderer打交道。（它可能是个组长，老师给它通知他广播给别人，这样别人就不用单独去访问orderer了） Org一个或多个peer组成org。在文件crypto-config.yaml中可以设置如下block指定一个org中peer数量。（这个是组织org也本身就是组织的缩写，把节点们放在一起也就是组织了） Channelchannel指一个在两个或多个特定网络成员间的专门以机密交易为目的而建立的私有&quot;子网&quot;。（类似网络中的局域网吧，建立网络让成员在网络中交易，当然这比局域网要安全得多）刚刚开始不知道为什么要实例化所以去了解了下 在 Fabric 中，channel 代表了一个私有的广播通道，保证了消息的隔离性和私密性，它由 orderer 来管理。channel 中的成员共享该 channel 的账本，并且只有通过验证的用户才能在 channel 中进行交易，与一个 channel 相关的属性记录在该channel的初始区块中，可通过 reconfiguration 交易进行更改。channel的初始区块由 create channel 交易生成，peer 向 orderer 发送该交易时会带有的 config.tx 文件，该文件定义 channel 的属性。总的来说他们的关系就是下图： fabric-ca-clientfabric-ca-client模块提供与可选组件fabric-ca进行交互的API，fabric-ca提供成员管理服务。fabric-ca-client模块主要功能有（注册新用户，注册用户以获得由fabric CA签名的注册证书，通过注册ID撤销现有的用户或撤销特定证书，可定制持久化存储）（简单来说就是注册，删除用户用的） （整整花费了一个下午和晚上才找齐了关于框架的各种资料，在慢慢罗列，理解，在写出来，头大），总结了下今天也就是把整个sdk中的各种模块都理解一遍，再把重要的几个给罗列出来","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"Fabric","slug":"Fabric","permalink":"http://yoursite.com/tags/Fabric/"}]},{"title":"记一次刷作业次数的脚本","slug":"记一次刷作业次数的脚本","date":"2019-10-15T09:44:51.000Z","updated":"2019-10-15T11:09:25.695Z","comments":false,"path":"2019/10/15/记一次刷作业次数的脚本/","link":"","permalink":"http://yoursite.com/2019/10/15/记一次刷作业次数的脚本/","excerpt":"","text":"教师次数刷新一个普通的登录界面 第一次输入账号密码后显示模拟发包应该发送的post地址，还有需要发送的数据包 百度后发现加密方式为base64，发包的时候需要加密一下，还有下载验证码图片到本地。然后登录后打开需要刷次数的url 重新发送这个包看看 发现它增加了，那只要发这个包就好了。 完成了一个，还有个学生页面的统计次数，这个页面我查看了好多次包也重新发送过试过很多次，发现都实现不了增加次数。 学生页面次数刷新但是手动刷新却可以，换个思路，决定在控制台打js代码了（哈哈哈哈哈） 次数增加了，搞定。 python贴部分代码，源码可去我的github中下载。源码：https://github.com/iiiJr/Homework下面贴一下js代码。 12345678910111213141516171819202122232425262728293031323334var timeout = prompt(\"设置刷新时间间隔[S]\"); // 获取当前的URL var current = location.href; if(timeout &gt; 0) &#123; // 时间间隔大于0，timeout秒之后执行reload函数 setTimeout('reload()', 1000 * timeout); &#125; else &#123; // 时间间隔不大于0，仅刷新一次 location.replace(current); &#125; function reload() &#123; // timeout秒后执行reload函数，实现无限循环刷新 setTimeout('reload()', 1000 * timeout); // 下面两行代码的格式化后的内容为： // &lt;frameset cols='*'&gt; // &lt;frame src='当前地址栏的URL' /&gt; // &lt;/frameset&gt; var fr4me = '&lt;frameset cols=\\'*\\'&gt;\\n&lt;frame src=\\'' + current + '\\' /&gt;'; fr4me += '&lt;/frameset&gt;'; with(document) &#123; // 引用document对象，调用write方法写入框架，打开新窗口 write(fr4me); // 关闭上面的窗口 void(close()); &#125;; &#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"队列","slug":"队列","date":"2019-10-12T10:38:54.000Z","updated":"2019-12-15T06:41:28.536Z","comments":false,"path":"2019/10/12/队列/","link":"","permalink":"http://yoursite.com/2019/10/12/队列/","excerpt":"","text":"ß 1.队列的概念只允许在一端插入数据操作，在另一端进行删除数据操作的特殊线性表；进行插入操作的一端称为队尾（入队列），进行删除操作的一端称为队头（出队列）；队列具有先进先出（FIFO）的特性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// main.cpp// Queue//// Created by ljr on 2019/10/12.// Copyright © 2019 ljr. All rights reserved.//#include &lt;iostream&gt;using namespace std;typedef struct QueueNode node;typedef struct QueueNode * link;struct QueueNode&#123; int data; struct QueueNode * next;&#125;;link front = NULL;link rear = NULL;void addQueue(int value)&#123; link newNode; newNode = (link)malloc(sizeof(node)); newNode -&gt; data = value; newNode -&gt; next = NULL; if (front == NULL) &#123; front = newNode; &#125;else&#123; rear -&gt; next = newNode; &#125; rear = newNode;&#125;int delQueue()&#123; link top; int temp; if (front != NULL) &#123; top = front; front = front -&gt; next; temp = top -&gt; data; free(top); return temp; &#125;else&#123; rear = NULL; return -1; &#125;&#125;void display()&#123; link point; point = front; while (point != NULL) &#123; cout &lt;&lt; point -&gt; data &lt;&lt; ' '; point = point -&gt; next; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int select; int temp = 0; while (1) &#123; cout &lt;&lt; \"1.input a data\\n\"; cout &lt;&lt; \"2.Output a data\\n\"; cout &lt;&lt; \"3.Exit\\n\"; cin &gt;&gt; select; switch (select) &#123; case 1: cout &lt;&lt; \"please input a value\\n\"; cin &gt;&gt; temp; addQueue(temp); break; case 2: if(delQueue() == -1) cout &lt;&lt; \"the queue is empty!\\n\"; else cout &lt;&lt; \"the out value is \" &lt;&lt; temp &lt;&lt; endl; break; case 3: return 0; &#125; system(\"clear\"); display(); &#125; return 0;&#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"栈","slug":"栈","date":"2019-10-11T09:49:43.000Z","updated":"2019-10-12T14:54:30.186Z","comments":false,"path":"2019/10/11/栈/","link":"","permalink":"http://yoursite.com/2019/10/11/栈/","excerpt":"","text":"用来自己学习用嘎 栈栈的主要特点就是先进后出；即后入的元素先出；可删除和增加元素操作的一端叫做栈顶；栈可以用指针来仿真也可以用数组来仿真；这里我用的是指针仿真栈；数组和指针仿真是不一样的，数组的话栈底一般为数组的第一个元素；而不是最后一个，因为在动态添加栈时如果栈顶是数组第一个元素的话就要使数组的每一个元素都移动一位；所以栈顶为数组最后一位数；指针的栈顶就是让原本的栈顶指向新插入的栈顶就可以了；栈底就是第一个插入的元素了；kk代码（函数中的代码都测试过，在主函数中调用既可）； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// main.cpp// stack//// Created by ljr on 2019/10/11.// Copyright © 2019 ljr. All rights reserved.//#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;typedef struct Stack * link;typedef struct Stack Snode;typedef int ElemType;//定义结构体struct Stack&#123; ElemType data; struct Stack * next;&#125;;//初始化栈link init()&#123; link p; p = NULL; return p;&#125;//入栈link push(link Head,ElemType x)&#123; link p; p = (link)malloc(sizeof(Snode)); if (p == NULL) &#123; cout &lt;&lt; \"\\nMemory Error\\n\"; &#125; p -&gt; data = x; p -&gt; next = Head; return p;&#125;//出栈link pop(link Head)&#123; link p; p = Head; if(p == NULL)&#123; cout &lt;&lt; \"\\nStack is Empty!\\n\"; &#125;else&#123; p = p -&gt; next; delete(Head); &#125; return p;&#125;//释放栈link setnull(link Head)&#123; link p; p = Head; while(p != NULL)&#123; p = p -&gt; next; delete Head; Head = p; &#125; return Head;&#125;//获取栈长度int lenth(link Head)&#123; int len = 0; link p; p = Head; while(p != NULL)&#123; len++; p = p -&gt; next; &#125; return len;&#125;//获取栈顶元素int gettop(link Head)&#123; if(Head == NULL)&#123; cout&lt;&lt;\"\\n Stack is empty\\n\"; return -1; &#125;else&#123; return Head -&gt; data; &#125;&#125;//显示栈void display(link Head)&#123; link p; p = Head; if (p == NULL) &#123; cout &lt;&lt; \"\\nStack is empty\\n\"; &#125;else&#123; do&#123; cout &lt;&lt; p -&gt; data &lt;&lt; \" \"; p = p -&gt; next; &#125;while(p != NULL); &#125;&#125;//主函数int main(void)&#123;// int i, x; link head1; head1 = init(); return 0;&#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"链表","slug":"链表","date":"2019-09-30T09:48:59.000Z","updated":"2019-10-12T14:54:26.819Z","comments":false,"path":"2019/09/30/链表/","link":"","permalink":"http://yoursite.com/2019/09/30/链表/","excerpt":"","text":"用来自己学习用嘎 头文件和结构1234567891011121314151617181920212223///// main.cpp// helloworld//// Created by ljr on 2019/9/29.// Copyright © 2019 ljr. All rights reserved.//#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct List * link; //代表链表指针typedef struct List Lnode; // 代表链表节点//结构struct List&#123; ElemType data; //创一个整型为例子8 struct List * next;&#125;; 创建链表函数123456789101112131415161718192021222324252627//创建链表link create(link Head)&#123; ElemType newData; link NewPoint; Head = (link)malloc(sizeof(Lnode)); printf(\"please input number: \\n\"); scanf(\"%d\",&amp;newData); Head -&gt; data = newData; Head -&gt; next = NULL; while(true)&#123; NewPoint = (link)malloc(sizeof(Lnode)); if(NewPoint == NULL) break; printf(\"please input number: input '-1' means exit\\n\"); scanf(\"%d\",&amp;newData); if (newData == -1) &#123; return Head; &#125; NewPoint -&gt; data = newData; NewPoint -&gt; next = Head; Head = NewPoint; &#125; return Head;&#125; 显示链表123456789101112//显示链表void display(link Head)&#123; link p; p = Head; if (p == NULL) &#123; printf(\"\\nList is empty\"); &#125;else&#123; do&#123; printf(\"%d\\n\", p -&gt; data); p = p -&gt; next; &#125;while(p != NULL); &#125;&#125; 插入节点、删除节点、获取节点、查找节点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//节点插入link insert(link Head,ElemType x,int i)&#123; link NewPoint,p = Head; int j = 1; NewPoint = (link)malloc(sizeof(Lnode)); NewPoint -&gt; data = x; if(i == 1)&#123; NewPoint -&gt; next = Head; Head = NewPoint; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125; &#125; if (j == i-1) &#123; NewPoint -&gt; next = p -&gt; next; p -&gt; next = NewPoint; &#125;else&#123; printf(\"insert is failure,i si not right\"); &#125; return Head;&#125;//删除节点link del(link Head,int i )&#123; int j=1; link p,t; p = Head; if(i == 1)&#123; p = p -&gt; next; free(Head); Head = p; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125;if(p -&gt; next != NULL &amp;&amp; j == i-1)&#123; t = p -&gt; next; p -&gt; next = t -&gt; next; &#125;if(t != NULL) free(t); &#125; return Head;&#125;//获取节点元素valueElemType get(link Head,int i)&#123; int j = 1; link p; p = Head; while (j &lt; i &amp;&amp; p != NULL ) &#123; p = p -&gt; next; j++; &#125; if (p != NULL) &#123; return (p -&gt; data); &#125;else&#123; printf(\"data is error!\"); return -1; &#125;&#125;//查找节点元素x的位置int locate(link Head, ElemType x)&#123; int n = 0; link p; p = Head; while (p != NULL &amp;&amp; p -&gt; data != x) &#123; p = p -&gt; next; n++; &#125; if(p == NULL)&#123; return -1; &#125;else&#123; return n+1; &#125;&#125; 链表逆置1234567891011121314151617//链表逆置link re(link Head)&#123; link p = Head; link n = NULL,temp; //n为保存的临时第一个链表节点，temp为第二个临时节点 if(p -&gt; next == NULL)&#123; return Head; &#125; while (p != NULL) &#123; temp = p; // 设置临时变量等于头节点 p = p -&gt; next; // 让p = p的下一个节点 temp -&gt; next = n; // 让p的下一个节点指向n n第一次是NULL 后面将会等于临时变量temp n = temp; // 让n = 要逆转的节点 &#125; return n;&#125; 其它功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546//返回链表的长度int lenth(link Head)&#123; int len = 0; link p; p = Head; while(p != NULL)&#123; len++; p = p -&gt; next; &#125; return len;&#125;//链接两个链表link connect(link Head1,link Head2)&#123; link p; p = Head1; while (p -&gt; next != NULL) &#123; p = p -&gt; next; &#125; p -&gt; next = Head2; return Head1;&#125;//比较两个链表int compare(link Head1,link Head2)&#123; link p1,p2; p1 = Head1; p2 = Head2; while (true) &#123; if((p1 -&gt; next == NULL)&amp;&amp;(p2 -&gt; next == NULL)) return 1; if (p1 -&gt; data != p2 -&gt; data) &#123; return 0; &#125;else&#123; p1 = p1 -&gt; next; p2 = p2 -&gt; next; &#125; &#125;&#125;//释放链表link setnull(link Head)&#123; link p; p = Head; while (p != NULL) &#123; p = p -&gt; next; free(Head); Head = p; &#125; return Head;&#125; main函数123456789101112131415161718192021222324252627282930313233343536373839404142434445int main()&#123; int l = 0; link head1 = NULL; link head2 = NULL; head1 = create(head1); printf(\"\\nHead1 is\\n\"); display(head1); head2 = create(head2); printf(\"\\nHead2 is\\n\"); display(head2); l = compare(head1, head2); printf(\"\\nl is %d\\n\",l); connect(head1, head2); printf(\"\\nHead1 + Head2 is\\n\"); display(head1); l = lenth(head1); printf(\"\\nlenth is %d\\n\",l); l = get(head1,3); printf(\"\\nget is %d\\n\",l); l = locate(head1, 12); printf(\"\\n locate 12 is %d\",l); head1 = insert(head1, 888, 5); display(head1); head1 = del(head1, 5); display(head1); printf(\"-------------逆置前kk---------------\\n\"); display(head1); printf(\"-------------逆置后kk---------------\\n\"); head1 = re(head1); display(head1); head1 = setnull(head1); display(head1);&#125; 完整代码可直接copy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249///// main.cpp// helloworld//// Created by ljr on 2019/9/29.// Copyright © 2019 ljr. All rights reserved.//#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct List * link; //代表链表指针typedef struct List Lnode; // 代表链表节点//结构struct List&#123; ElemType data; //创一个整型为例子8 struct List * next;&#125;;//创建链表link create(link Head)&#123; ElemType newData; link NewPoint; Head = (link)malloc(sizeof(Lnode)); printf(\"please input number: \\n\"); scanf(\"%d\",&amp;newData); Head -&gt; data = newData; Head -&gt; next = NULL; while(true)&#123; NewPoint = (link)malloc(sizeof(Lnode)); if(NewPoint == NULL) break; printf(\"please input number: input '-1' means exit\\n\"); scanf(\"%d\",&amp;newData); if (newData == -1) &#123; return Head; &#125; NewPoint -&gt; data = newData; NewPoint -&gt; next = Head; Head = NewPoint; &#125; return Head;&#125;//显示链表void display(link Head)&#123; link p; p = Head; if (p == NULL) &#123; printf(\"\\nList is empty\"); &#125;else&#123; do&#123; printf(\"%d\\n\", p -&gt; data); p = p -&gt; next; &#125;while(p != NULL); &#125;&#125;//节点插入link insert(link Head,ElemType x,int i)&#123; link NewPoint,p = Head; int j = 1; NewPoint = (link)malloc(sizeof(Lnode)); NewPoint -&gt; data = x; if(i == 1)&#123; NewPoint -&gt; next = Head; Head = NewPoint; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125; &#125; if (j == i-1) &#123; NewPoint -&gt; next = p -&gt; next; p -&gt; next = NewPoint; &#125;else&#123; printf(\"insert is failure,i si not right\"); &#125; return Head;&#125;//删除节点link del(link Head,int i )&#123; int j=1; link p,t; p = Head; if(i == 1)&#123; p = p -&gt; next; free(Head); Head = p; &#125;else&#123; while (j &lt; i-1 &amp;&amp; p -&gt; next != NULL) &#123; p = p -&gt; next; j++; &#125;if(p -&gt; next != NULL &amp;&amp; j == i-1)&#123; t = p -&gt; next; p -&gt; next = t -&gt; next; &#125;if(t != NULL) free(t); &#125; return Head;&#125;//获取节点元素valueElemType get(link Head,int i)&#123; int j = 1; link p; p = Head; while (j &lt; i &amp;&amp; p != NULL ) &#123; p = p -&gt; next; j++; &#125; if (p != NULL) &#123; return (p -&gt; data); &#125;else&#123; printf(\"data is error!\"); return -1; &#125;&#125;//查找节点元素x的位置int locate(link Head, ElemType x)&#123; int n = 0; link p; p = Head; while (p != NULL &amp;&amp; p -&gt; data != x) &#123; p = p -&gt; next; n++; &#125; if(p == NULL)&#123; return -1; &#125;else&#123; return n+1; &#125;&#125;//返回链表的长度int lenth(link Head)&#123; int len = 0; link p; p = Head; while(p != NULL)&#123; len++; p = p -&gt; next; &#125; return len;&#125;//链接两个链表link connect(link Head1,link Head2)&#123; link p; p = Head1; while (p -&gt; next != NULL) &#123; p = p -&gt; next; &#125; p -&gt; next = Head2; return Head1;&#125;//比较两个链表int compare(link Head1,link Head2)&#123; link p1,p2; p1 = Head1; p2 = Head2; while (true) &#123; if((p1 -&gt; next == NULL)&amp;&amp;(p2 -&gt; next == NULL)) return 1; if (p1 -&gt; data != p2 -&gt; data) &#123; return 0; &#125;else&#123; p1 = p1 -&gt; next; p2 = p2 -&gt; next; &#125; &#125;&#125;//释放链表link setnull(link Head)&#123; link p; p = Head; while (p != NULL) &#123; p = p -&gt; next; free(Head); Head = p; &#125; return Head;&#125;//链表逆置link re(link Head)&#123; link p = Head; link n = NULL,temp; //n为保存的临时第一个链表节点，temp为第二个临时节点 if(p -&gt; next == NULL)&#123; return Head; &#125; while (p != NULL) &#123; temp = p; // 设置临时变量等于头节点 p = p -&gt; next; // 让p = p的下一个节点 temp -&gt; next = n; // 让p的下一个节点指向n n第一次是NULL 后面将会等于临时变量temp n = temp; // 让n = 要逆转的节点 &#125; return n;&#125;int main()&#123; int l = 0; link head1 = NULL; link head2 = NULL; head1 = create(head1); printf(\"\\nHead1 is\\n\"); display(head1); head2 = create(head2); printf(\"\\nHead2 is\\n\"); display(head2); l = compare(head1, head2); printf(\"\\nl is %d\\n\",l); connect(head1, head2); printf(\"\\nHead1 + Head2 is\\n\"); display(head1); l = lenth(head1); printf(\"\\nlenth is %d\\n\",l); l = get(head1,3); printf(\"\\nget is %d\\n\",l); l = locate(head1, 12); printf(\"\\n locate 12 is %d\",l); head1 = insert(head1, 888, 5); display(head1); head1 = del(head1, 5); display(head1); printf(\"-------------逆置前kk---------------\\n\"); display(head1); printf(\"-------------逆置后kk---------------\\n\"); head1 = re(head1); display(head1); head1 = setnull(head1); display(head1);&#125; 2019.10.09 增加递归逆置链表；123456789101112131415161718192021222324252627282930313233343536373839404142//测试代码如下#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct List * link; //代表链表指针typedef struct List Lnode; // 代表链表节点//结构struct List&#123; ElemType data; //创一个整型为例子8 struct List * next;&#125;;List * reverseList(List * Head)&#123; //如果链表为空或者链表中只有一个元素 if (Head -&gt; next == NULL || Head == NULL) &#123; return Head; &#125;else&#123; List * newHead = reverseList(Head -&gt; next); //先反转后面的链表 Head -&gt; next -&gt; next = Head; //再将当前节点设置为其然来后面节点的后续节点 Head -&gt; next = NULL; return newHead; &#125;&#125;int main()&#123; link head1 = NULL; head1 = create(head1); printf(\"\\nHead1 is\\n\"); printf(\"-------------逆置前kk---------------\\n\"); display(head1); printf(\"-------------逆置后kk---------------\\n\"); head1 = reverseList(head1); display(head1);&#125;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"git","slug":"git","date":"2019-09-29T09:48:19.000Z","updated":"2019-10-12T15:30:53.488Z","comments":false,"path":"2019/09/29/git/","link":"","permalink":"http://yoursite.com/2019/09/29/git/","excerpt":"","text":"记一次小作业默认已经下载git第一步先生成ssh秘钥吧哈哈哈哈，具体创建方法看下面的网址8。 https://blog.csdn.net/lucky__yang/article/details/80148420 好了后就开始创建个仓库8.不会创建？那看这个，看到创建完仓库8. https://blog.csdn.net/qq_35869389/article/details/79472564 再在本地计算机中创建一个test文件夹 随便打点东西在cpp中 进入文件夹后再Git中输入init 再输入git status查看文件下都有什么文件 利用 git add main.cpp添加文件在打一次Git status就会有绿色的文件表示成功 最后成功","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"from表单提交检测","slug":"from表单提交检测","date":"2019-09-21T09:46:56.000Z","updated":"2019-10-12T14:54:40.883Z","comments":false,"path":"2019/09/21/from表单提交检测/","link":"","permalink":"http://yoursite.com/2019/09/21/from表单提交检测/","excerpt":"","text":"以前一直认为form是只能直接提交数据的，直到今天突然发现先看看一个简单的html代码：一个简单的提交没什么的 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"login.css\" type=\"text/css\"&gt; &lt;script type=\"text/javascript\" src=\"jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"login.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"loginBigArea\" &gt; &lt;div class=\"loginInsideArea\"&gt; &lt;form id=\"loginForm\" action=\"login\"&gt; &lt;div class=\"loginTitle\"&gt;登录&lt;/div&gt; &lt;input type=\"text\" placeholder=\"学号\" class=\"scanf\" id=\"stuNum\"&gt;&lt;br&gt; &lt;input type=\"password\" placeholder=\"密码\" class=\"scanf\" id=\"pwd\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"subBut\"&gt;&lt;br&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在来看看js中的代码 12345678910111213141516171819202122232425262728293031323334function checkStuNum() &#123; var num = $(\"#stuNum\").val(); var reg_num = /^\\w&#123;8&#125;$/; var flag = reg_num.test(num); if(flag)&#123; $(\"#stuNum\").css(\"border\",\"1px solid #5eb6de\"); &#125;else&#123; $(\"#stuNum\").css(\"border\",\"1px solid red\"); &#125; return flag; //这里返回的数据如果是false，那表单将不会提交&#125;function checkPwd() &#123; var pwd = $(\"#pwd\").val(); var reg_pwd = /^\\w&#123;6,20&#125;$/; var flag = reg_pwd.test(pwd); if(flag)&#123; $(\"#pwd\").css(\"border\",\"1px solid #5eb6de\"); &#125;else&#123; $(\"#pwd\").css(\"border\",\"1px solid red\"); &#125; return flag; //这里返回的数据如果是false，那表单将不会提交&#125;$(function () &#123; //当表单提交时调用所有校验方法 $(\"#loginForm\").submit(function () &#123; return checkStuNum() &amp;&amp; checkPwd(); &#125;); //当鼠标失去焦点，调用校验方法 $(\"#stuNum\").blur(checkStuNum); $(\"#pwd\").blur(checkPwd);&#125;) 是的，这样做之后，表单会在检测之后才提交！！！可能是我没好好学js的原因吧，才知道可以这样子。","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"ajax","slug":"ajax","date":"2019-09-21T09:45:52.000Z","updated":"2019-10-12T14:54:33.978Z","comments":false,"path":"2019/09/21/ajax/","link":"","permalink":"http://yoursite.com/2019/09/21/ajax/","excerpt":"","text":"自己遇到的小问题 ajax提交后获取不到数据#2019/05/26 123456&lt;form id=\"loginForm\" action=\"../checkLoginServlet\"&gt;&lt;div class=\"loginTitle\"&gt;登录&lt;/div&gt;&lt;input type=\"text\" placeholder=\"学号\" class=\"scanf\" id=\"stuNum\"&gt;&lt;br&gt;&lt;input type=\"password\" placeholder=\"密码\" class=\"scanf\" id=\"pwd\" &gt;&lt;br&gt;&lt;input type=\"submit\" class=\"subBut\"&gt;&lt;br&gt;&lt;/form&gt; 提交不到数据时我是这样写的 1234567//后来才知道，表单序列化 都是user=xxx&amp;xxx 这种格式，所以需要在&lt;input&gt;标签中添加一个name，才能序列号 &lt;form id=\"loginForm\" action=\"../checkLoginServlet\"&gt; &lt;div class=\"loginTitle\"&gt;登录&lt;/div&gt; &lt;input type=\"text\" placeholder=\"学号\" class=\"scanf\" id=\"stuNum\" name=\"stuNum\"&gt;&lt;br&gt; &lt;input type=\"password\" placeholder=\"密码\" class=\"scanf\" id=\"pwd\" name=\"pwd\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"subBut\"&gt;&lt;br&gt; &lt;/form&gt;","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"js转jquery","slug":"js转jquery","date":"2019-09-21T09:44:23.000Z","updated":"2019-10-12T14:55:00.387Z","comments":false,"path":"2019/09/21/js转jquery/","link":"","permalink":"http://yoursite.com/2019/09/21/js转jquery/","excerpt":"","text":"js对象转换成jquery对象#2019/05/26 123456789//serialize() 方法通过序列化表单值，创建 URL 编码文本字符串。//你可以选择一个或多个表单元素（比如 input 及/或 文本框），或者 form 元素本身。//序列化的值可在生成 AJAX 请求时用于 URL 查询字符串中。$(\"form\").serialize()//输出后会变成a=1&amp;b=2&amp;c=3&amp;d=4&amp;e=5","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"docker","slug":"docker","date":"2019-09-19T09:42:48.000Z","updated":"2019-10-12T14:54:37.448Z","comments":false,"path":"2019/09/19/docker/","link":"","permalink":"http://yoursite.com/2019/09/19/docker/","excerpt":"","text":"docke的基本使用:容器的创建还有镜像的下载看网址就好：1https://www.runoob.com/docker/docker-install-tomcat.html 常用命令大全： 先了解下基础操作命令 镜像: 应用程序所依赖的操作环境和配置形成的模板，用面向对象的话来说简称类 容器: 通过镜像来运行容器，容器相当于类的实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576ip addr/ip link/ ifconfig：查看宿主机里ip地址（宿主机表示是虚拟机)systemctl start docker/service start docker：启动docker服务systemctl stop docker:关闭docker服务service iptables start:启动防火墙service iptables restart:重启防火墙service iptables stop:关闭防火墙docker run：启动containerdocker seach xxxx(镜像名称):检索镜像docker pull xxx(镜像名称）：拉取镜像docker images:列出镜像docker --version:查看docker的版本信息[root@localhost ~]:家目录[root@localhost /]:根目录docker exec Container Id:进入容器docker exec -it NAMES(自定义名称) /bin/bash:进入--name命名的容器docker exec NAMES(容器的自定义名称）-it bash:进入容器里进行操作docker attach Container Id:进入到容器的终端docker inspect IMAGE ID:显示容器或镜像的元数据[root@（container id）]：比如[root@24527d42d3eb]表示已进入docker里的一个CONTAINER ID的容器内部[root@24527d42d3eb]:exit(从容器里退出）。docker ps：查看docker里运行的容器（status为Up....表示运行中）docker ps -a:查看docker里已停止或正在运行的容器（status为Exit)docker start CONTAINER ID ：如果容器的状态为Exit,用它来启动容器docker stop CONTAINER ID :停止正在运行的容器，删除一个容器必须先要停止docker restart :当部署web项目的war文件，到tomcat里的webapps里面了，重启一下docker服务，就自动解压了war文件docker rm CONTAINER ID ：删除容器docker rm $(docker ps -a -q)：删除所有已停止的容器;docekr rmi IMAGE ID:删除镜像rm -rf xxxx：强制删除某个war.文件或目录、文件docker cp /xxx.war CONTAINER ID :/usr/local/tomcat/webapps：从/根目录复制一个打包后的Java web war文件 到tomcat容器里的webapps工作目录里docker exec CONTAINER ID ls /usr/local/tomcat:默认的 安装tomcat镜像的webapps目录docker run -name xxx -p (自定义端口号,用来访问的):(容器的端口号：比如tomcat的8080，mysql的3306） -d docker.io/tomcat(镜像名称)：表示在docker里运行一个tomcat容器,如果没有镜像，自动pull一个tomcat的镜像--name 为容器取一个名字-p 容器要映射的端口号-d:后台运行-t：进入终端-i：获得一个交互式的连接，通过获取container的输入/bin/bash：在container中启动一个bash shell 因为我只在docker中建立了tomcat的和mysql两个环境，所以这里就只讲讲tomcat和mysql的创建： 开始安装tomcat1234567891011输入这条命令docker run --name tomcat -p 8080:8080 -d tomcat在用docker ps查看的时候显示的是eee4f17b3f78 tomcat \"catalina.sh run\" 15 seconds ago Up 14 seconds 0.0.0.0:8080-&gt;8080/tcp tomcat默认是0.0.0.0:8080登录这个网址就会出现tomcat主页127.0.0.1:8080不行，就去百度了一下端口映射的问题然后发现在创建的时候用这条语句之后就可以访问了将本机的端口映射过去了，在本机浏览器中输入127.0.0.1:8080或localhost:8080既可docker run --name tomcat -p 127.0.0.1:8080:8080 -d tomcat mysql的话12345这条语句就搞定了 其中的东西自己配置docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7然后输入docker exec -it mysql /bin/bashmysql -uroot -p123456 测试成功；就Vans了","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"scrapy","slug":"scrapy","date":"2019-09-18T09:38:44.000Z","updated":"2019-10-12T14:55:04.208Z","comments":false,"path":"2019/09/18/scrapy/","link":"","permalink":"http://yoursite.com/2019/09/18/scrapy/","excerpt":"","text":"Scrapy框架的安装先pip install wheel,在去 1https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载 1lxml‑4.3.4‑cp36‑cp36m‑win_amd64.whll 注意根据型号什么的下载，然后再 1pip install 下载的文件地址 然后再去 1https://pypi.org/project/pyOpenSSL/#downloads 下载 1pyOpenSSL-19.0.0-py2.py3-none-any.whl 继续 1https://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载 1twain‑1.0.4‑cp36‑cp36m‑win_amd64.whl 继续 1https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/ 下载 12pywin32-221.win-AMD64-py3.6.exe (这个我没找到最后用pip install pywin32成功安装的溜了溜了。) 遇到了各种问题，我累了，懒得一一列出来 scrapy调试工具命令行中输入 1scrapy shell http://lab.scrapyd.cn scrapy shell 固定格式，后面的话跟的是你要调试的页面，如果是百度就： 1scrapy shell (http://www.baidu.com)(URL可改变) 就这样一个格式，其实这段代码就是一个下载的过程，一执行这么一段代码scrapy就立马把我们相应链接的相应页面给拿到了，那接下来就可以任你处置了。 在要提前的调试界面In中输入 1response.css('title') 之类的语句就可以自动调试了 scrapy框架的基本使用在需要创建的目录下打开cmd 1然后输入 scrapy startproject /项目名称/. 在输入需要爬取的URL进入创建的目录下 1输入 scrapy genspider quotes /URL/. 这里也可以手动创建一个python文件，同理: 12345678910111213141516171819202122232425262728293031323334import scrapyclass mingyan(scrapy.Spider): #需要继承scrapy.Spider类 name = \"mingyan2\" # 定义蜘蛛名 def start_requests(self): # 由此方法通过下面链接爬取页面 # 定义爬取的链接 urls = [ 'http://lab.scrapyd.cn/page/1/', 'http://lab.scrapyd.cn/page/2/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) #爬取到的页面如何处理？提交给parse方法处理 def parse(self, response): ''' start_requests已经爬取到页面，那如何提取我们想要的内容呢？那就可以在这个方法里面定义。 这里的话，并木有定义，只是简单的把页面做了一个保存，并没有涉及提取我们想要的数据，后面会慢慢说到 也就是用xpath、正则、或是css进行相应提取，这个例子就是让你看看scrapy运行的流程： 1、定义链接； 2、通过链接爬取（下载）页面； 3、定义规则，然后提取数据； 就是这么个流程，4不4很简单呀？ ''' page = response.url.split(\"/\")[-2] #根据上面的链接提取分页,如：/page/1/，提取到的就是：1 filename = 'mingyan-%s.html' % page #拼接文件名，如果是第一页，最终文件名便是：mingyan-1.html with open(filename, 'wb') as f: #python文件操作，不多说了； f.write(response.body) #刚才下载的页面去哪里了？response.body就代表了刚才下载的页面！ self.log('保存文件: %s' % filename) # 打个日志 scrapy css选择器的使用12输入response.css('title')可以得到[&lt;Selector xpath='descendant-or-self::title' data='&lt;title&gt;xxxxxxxxxxxxxxxxx&lt;/title&gt;'&gt;]类似的东西 如果你加上 1234567891011response.css('title').extract()这个他就会变成['&lt;title&gt;xxxxxxxxxxx&lt;/title&gt;']列表的形式，如果不需要列表可以这样。response.css('title').extract_first()，那么爬下来的数据为这样 '&lt;title&gt;xxxxxxxxxxx&lt;/title&gt;' extract_first()就代表提取第一个元素（我想这个谁都看得出来） 当然如果你觉得怎么多了个title标签 那你可以这样： response.css('title::text').extract_first() 这样爬下来的数据就是xxxxxxxxxxx了 我们该如何提取URL呢？提取属性我们是用：“标签名::attr(属性名)”，比如我们要提取url表达式就是：a::attr(href)，要提取图片地址的表达式就是：img::attr(src)……以此类推：获取所有a标签下的所以href 1response.css(\"a::attr(href)\") 获取固定class样式下的标签 1response.css(\".page-navigator a::attr(href)\").extract() 如果是src那就要这样写 1response.css(\".xxxx img::attr(src)\").extract() 还有好多,自己发挥。 xpath提取数据123456nodename = 选取此节点的所有子节点。/ = 从根节点选取。// = 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。. = 选取当前节点。.. = 选取当前节点的父节点。@ = 选取属性。 response.xpath(“表达式”)，提取属性的话既然使用：@，那我们要提取href就是：@href 12In: response.xpath(\"@href\")out: [] 可以看到输出为0,因为我们木有限定从哪里提取,一般我们都需要加个：//，再来试试 1234567891011121314In: response.xpath(\"//@href\")out: [&lt;Selector xpath='//@href' data='//cdnjscn.b0.upaiyun.com/libs/normalize/'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/usr/themes/default'&gt;, …… &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E7%8E%8B%E5%B'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E6%99%BA%E6%8'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E6%B3%B0%E6%8'&gt;,…… &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/tag/%E8%AF%8D/'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn'&gt;, &lt;Selector xpath='//@href' data='http://bbs.scrapyd.cn'&gt;, &lt;Selector xpath='//@href' data='http://www.scrapyd.cn'&gt;, &lt;Selector xpath='//@href' data='http://lab.scrapyd.cn/'&gt;] 已经提取到了，只是这是这个页面所有的href，并非是我们想要的，那和css选择一样我们需要加以限制.例如一个ol标签下 123456789In: response.xpath(\"//ol//@href\")Out:[&lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/1/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/2/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/3/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/4/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/6/'&gt;, &lt;Selector xpath='//ol//@href' data='http://lab.scrapyd.cn/page/2/'&gt;] “//ol//@href”，这个表达式表示：ol标签下所有的href属性值，可以看到我们这里限定了html的ol标签，这里的话页面只有一个ol，不会出错，如果页面中有多个ol，那就不一定能得到我们想要的结果,这里我们还能限定我们的属性，使用的是：标签[@属性名=’属性值’]； 例如： 123&lt;ol class=\"page-navigator\"&gt; ……&lt;/ol&gt; 里面有个：class=“page-navigator”，那我们就可以这样限制：//ol[@class=”page-navigator”]//@href 好了，这样的话就能让ol尽量缩小范围，我们再来试试这个代码效果： 1234567891011121314In : response.xpath(\"//ol[@class='page-navigator']//@href\")Out:[&lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/1/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/2/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/3/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/4/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/6/'&gt;, &lt;Selector xpath=\"//ol[@class='page-navigator']//@href\" data='http://lab.scrapyd.cn/page/2/'&gt;] 可以看到也是同样得到想要的效果，以此类推，可以根据自己的情况来缩小范围如果这里的属性是id那就：ol[@id=’page-navigator’]和css选择器一样，xpath中也有extract（）、extract_first()这两个函数，加上就可以提取纯粹的href值了 ——————————–分割 接下来我们提取标签里面的内容，表达式： //text()，其实就是提取文本（不想说了，放个例子你们会懂得） 12In : response.xpath(\"//title//text()\").extract()Out: ['xxxxxxxxxxx'] 可以看到，表达式为：//title//text() ，就是用到了：//text() 这个表达式，前面的：//title是限定你要提取的范围，同理如果你要提取首页右侧的标签，如下： 12345678910111213141516171819&lt;ul class=\"tags-list\"&gt; &lt;li&gt;&lt;a style=\"color:rgb(101,86, 72)\" href=\"http://lab.scrapyd.cn/tag/%E4%BA%BA%E7%94%9F/\"&gt; 人生&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a style=\"color:rgb(214,236, 5)\" href=\"http://lab.scrapyd.cn/tag/%E5%8A%B1%E5%BF%97/\"&gt; 励志&lt;/a&gt;&lt;/li&gt; …… &lt;li&gt;&lt;a style=\"color:rgb(4,4, 41)\" href=\"http://lab.scrapyd.cn/tag/%E7%BB%9D%E4%B8%96%E5%A5%BD%E8%AF%8D/\"&gt; 绝世好词&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a style=\"color:rgb(204,12, 225)\" href=\"http://lab.scrapyd.cn/tag/%E6%9C%A8%E5%BF%83/\"&gt; 木心&lt;/a&gt;&lt;/li&gt; …… &lt;li&gt;&lt;a href=\"http://lab.scrapyd.cn\"&gt;返回首页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"http://bbs.scrapyd.cn\" target=\"_blank\"&gt;SCRAPY中文社区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.scrapyd.cn\" target=\"_blank\"&gt;SCRAPY中文网&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 可以看到标签文字是在 “class=tags-list” 的ul里面，那我们就可以这样写表达式：//ul[@class=’tags-list’]//a//text()，具体代码如下： 1234567891011121314151617In [5]: response.xpath(\"//ul[@class='tags-list']//a//text()\").extract()Out[5]:['\\r\\n 人生', '\\r\\n 励志', '\\r\\n 爱情', '\\r\\n 王尔德', '\\r\\n 智慧', '\\r\\n 泰戈尔', '\\r\\n 绝世好词', '\\r\\n 木心', '\\r\\n 艺术', '\\r\\n 名画', '\\r\\n 生活', '\\r\\n 词', '返回首页', 'SCRAPY中文社区', 'SCRAPY中文网'] 可以看到经过这样的限制，我们就定位到了； ——————–分割线 包含HTML标签的所有文字内容提取：string() 如果我们用表达式：//div[@class=’post-content’]//text()，你会发现虽然能提取但是一个列表，不是整段文字：那这里我们就用到一个xpath函数：string()，我们可以把表达式这样写：response.xpath(“string(//div[@class=’post-content’])”).extract()，可看到我们没有使用：text()，而是用：string(要提取内容的标签)，这样的话就能把数据都提取出来了，而且都合成为一条。","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-17T05:38:44.000Z","updated":"2019-10-12T14:54:54.856Z","comments":false,"path":"2019/09/17/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/17/hello-world/","excerpt":"","text":"note很久前就想自己搭个博客，当时想自己手写前端后端，终于在最后放弃了(Hexo真香)这里我就放平时自己做做的菜鸡笔记还有一些自己遇到的弱鸡问题好了 1$ My first note","categories":[{"name":"study","slug":"study","permalink":"http://yoursite.com/categories/study/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]}